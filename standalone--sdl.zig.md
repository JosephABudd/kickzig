
The local sqlite store is initialized in standalone-sdl.zig and then added to the back-end's startup params so that the back-end has access to the store.

## Additions related to Store

* line 17
* lines 62 - 73
* line 100

```zig
  1 ⎥ /// This is where the application starts.
  2 ⎥ /// This file was generated by kickzig when you created the framework.
  3 ⎥ /// This file will be never be touched by kickzig.
  4 ⎥ /// You are free to edit this file.
  5 ⎥ const std = @import("std");
  6 ⎥ const dvui = @import("dvui");
  7 ⎥ const SDLBackend = @import("SDLBackend");
  8 ⎥ 
  9 ⎥ const _backend_ = @import("src/@This/backend/api.zig");
 10 ⎥ const _channel_ = @import("channel");
 11 ⎥ const _closer_ = @import("closer");
 12 ⎥ const _closedownjobs_ = @import("closedownjobs");
 13 ⎥ const _framers_ = @import("framers");
 14 ⎥ const _frontend_ = @import("src/@This/frontend/api.zig");
 15 ⎥ const _modal_params_ = @import("modal_params");
 16 ⎥ const _startup_ = @import("startup");
 17 ⎥ const Store = @import("store").Store;
 18 ⎥ 
 19 ⎥ const window_icon_png = @embedFile("src/vendor/dvui/src/zig-favicon.png");
 20 ⎥ 
 21 ⎥ // General Purpose Allocator for frontend-state, backend and channels.
 22 ⎥ var gpa_instance = std.heap.GeneralPurposeAllocator(.{}){};
 23 ⎥ const gpa = gpa_instance.allocator();
 24 ⎥ 
 25 ⎥ const vsync = true;
 26 ⎥ var show_dialog_outside_frame: bool = false;
 27 ⎥ 
 28 ⎥ /// This example shows how to use the dvui for a normal application:
 29 ⎥ /// - dvui renders the whole application
 30 ⎥ /// - render frames only when needed
 31 ⎥ pub fn main() !void {
 32 ⎥     // init SDL gui_backend (creates OS window)
 33 ⎥     var gui_backend = try SDLBackend.init(.{
 34 ⎥         .size = .{ .w = 500.0, .h = 200.0 },
 35 ⎥         // .min_size = .{ .w = 500.0, .h = 400.0 },
 36 ⎥         .vsync = vsync,
 37 ⎥         .title = "crud",
 38 ⎥         .icon = window_icon_png, // can also call setIconFromFileContent()
 39 ⎥     });
 40 ⎥     defer gui_backend.deinit();
 41 ⎥ 
 42 ⎥     // init dvui Window (maps onto a single OS window)
 43 ⎥     var win = try dvui.Window.init(@src(), 0, gpa, gui_backend.backend());
 44 ⎥     win.content_scale = gui_backend.initial_scale * 1.5;
 45 ⎥     defer win.deinit();
 46 ⎥ 
 47 ⎥     var all_screens: *_framers_.Group = undefined;
 48 ⎥     var finish_up_jobs: *_closedownjobs_.Jobs = undefined;
 49 ⎥     // init the finish_up_jobs.
 50 ⎥     finish_up_jobs = try _closedownjobs_.Jobs.init(gpa);
 51 ⎥     defer finish_up_jobs.deinit();
 52 ⎥     const exit: *const fn (user_message: []const u8) void = try _closer_.init(gpa, finish_up_jobs);
 53 ⎥     defer _closer_.deinit();
 54 ⎥ 
 55 ⎥     // The channels between the front and back ends.
 56 ⎥     const backToFront: *_channel_.BackendToFrontend = try _channel_.BackendToFrontend.init(gpa, exit);
 57 ⎥     defer backToFront.deinit();
 58 ⎥     const frontToBack: *_channel_.FrontendToBackend = try _channel_.FrontendToBackend.init(gpa, exit);
 59 ⎥     defer frontToBack.deinit();
 60 ⎥     const triggers: *_channel_.Trigger = try _channel_.Trigger.init(backToFront, exit);
 61 ⎥ 
 62 ⎥     // The store.
 63 ⎥     var app_data_path: []const u8 = try std.fs.getAppDataDir(gpa, "crud");
 64 ⎥     defer gpa.free(app_data_path);
 65 ⎥     std.fs.makeDirAbsolute(app_data_path) catch |err| {
 66 ⎥         if (err != error.PathAlreadyExists) {
 67 ⎥             return;
 68 ⎥         }
 69 ⎥     };
 70 ⎥     var params = [2][]const u8{ app_data_path, "store.sqlite" };
 71 ⎥     var store_pathZ: [:0]const u8 = try std.fs.path.joinZ(gpa, &params);
 72 ⎥     var store: *Store = try Store.init(gpa, store_pathZ);
 73 ⎥     defer store.deinit();
 74 ⎥ 
 75 ⎥     // Initialize the front end.
 76 ⎥     // See src/@This/deps/startup/api.zig
 77 ⎥     var startup_frontend: *_startup_.Frontend = try _startup_.Frontend.init(
 78 ⎥         gpa,
 79 ⎥         &win,
 80 ⎥         frontToBack,
 81 ⎥         backToFront,
 82 ⎥         finish_up_jobs,
 83 ⎥         exit,
 84 ⎥     );
 85 ⎥     all_screens = try _framers_.init(gpa, exit);
 86 ⎥     defer all_screens.deinit();
 87 ⎥     _closer_.set_screens(all_screens);
 88 ⎥     startup_frontend.setAllScreens(all_screens);
 89 ⎥     try _frontend_.init(startup_frontend.*);
 90 ⎥ 
 91 ⎥     // Initialize and kick-start the back end.
 92 ⎥     try _backend_.init(
 93 ⎥         .{
 94 ⎥             .allocator = gpa,
 95 ⎥             .send_channels = backToFront,
 96 ⎥             .receive_channels = frontToBack,
 97 ⎥             .finish_up_jobs = finish_up_jobs,
 98 ⎥             .triggers = triggers,
 99 ⎥             .exit = exit,
100 ⎥             .store = store,
101 ⎥         },
102 ⎥     );
103 ⎥     defer _backend_.deinit();
104 ⎥ 
105 ⎥     // KICKZIG TODO: See backend.kickStart();
106 ⎥     try _backend_.kickStart();
107 ⎥ 
108 ⎥     var theme_set: bool = false;
109 ⎥     main_loop: while (true) {
110 ⎥ 
111 ⎥         // Arena allocator for the frontend frame functions.
112 ⎥         var arena_allocator = std.heap.ArenaAllocator.init(std.heap.page_allocator);
113 ⎥         defer arena_allocator.deinit();
114 ⎥         var arena = arena_allocator.allocator();
115 ⎥ 
116 ⎥         // beginWait coordinates with waitTime below to run frames only when needed
117 ⎥         var nstime = win.beginWait(gui_backend.hasEvent());
118 ⎥ 
119 ⎥         // marks the beginning of a frame for dvui, can call dvui functions after this
120 ⎥         try win.begin(nstime);
121 ⎥ 
122 ⎥         // set the theme.
123 ⎥         if (!theme_set) {
124 ⎥             theme_set = true;
125 ⎥             const dark_theme = &dvui.Adwaita.dark;
126 ⎥             dvui.themeSet(dark_theme);
127 ⎥         }
128 ⎥ 
129 ⎥         // send all SDL events to dvui for processing
130 ⎥         const quit = try gui_backend.addAllEvents(&win);
131 ⎥         const state = _closer_.context();
132 ⎥         switch (state) {
133 ⎥             .none => blk: {
134 ⎥                 if (quit) {
135 ⎥                     _closer_.close("Bye-bye.");
136 ⎥                 }
137 ⎥                 break :blk;
138 ⎥             },
139 ⎥             .started => blk: {
140 ⎥                 // already quitting so ignore quit.
141 ⎥                 break :blk;
142 ⎥             },
143 ⎥             .completed => {
144 ⎥                 std.log.debug("break :main_loop;", .{});
145 ⎥                 break :main_loop;
146 ⎥             },
147 ⎥         }
148 ⎥ 
149 ⎥         // if dvui widgets might not cover the whole window, then need to clear
150 ⎥         // the previous frame's render
151 ⎥         gui_backend.clear();
152 ⎥ 
153 ⎥         try _frontend_.frame(arena, all_screens);
154 ⎥ 
155 ⎥         // marks end of dvui frame, don't call dvui functions after this
156 ⎥         // - sends all dvui stuff to gui_backend for rendering, must be called before renderPresent()
157 ⎥         const end_micros = try win.end(.{});
158 ⎥ 
159 ⎥         // cursor management
160 ⎥         gui_backend.setCursor(win.cursorRequested());
161 ⎥ 
162 ⎥         // render frame to OS
163 ⎥         gui_backend.renderPresent();
164 ⎥ 
165 ⎥         // waitTime and beginWait combine to achieve variable framerates
166 ⎥         const wait_event_micros = win.waitTime(end_micros, null);
167 ⎥         gui_backend.waitEventTimeout(wait_event_micros);
168 ⎥ 
169 ⎥         // Example of how to show a dialog from another thread (outside of win.begin/win.end)
170 ⎥         if (show_dialog_outside_frame) {
171 ⎥             show_dialog_outside_frame = false;
172 ⎥             try dvui.dialog(@src(), .{ .window = &win, .modal = false, .title = "Dialog from Outside", .message = "This is a non modal dialog that was created outside win.begin()/win.end(), usually from another thread." });
173 ⎥         }
174 ⎥     }
175 ⎥ }
176 ⎥ 
```
