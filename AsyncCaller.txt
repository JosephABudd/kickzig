const struct DoitState = {
    allocator: std.mem.Allocator,
    doing_it: bool,

    fn init(allocator: std.mem.Allocator, doing_it: bool) !*DoitState {
        var state: *DoitState = &DoitState{
            doing_it: doing_it,
        }
        return state;
    }

    fn deinit() void {
        self.allocator.destroy(self);
    }
}

const AsyncCaller = struct {
    
    fn callInit(self: *AsyncCaller) !void {
        var state = &DoitState.init(self.allocator, true);
        something: *otherpackage.Something = try otherpackage.Something.init(self.allocator);
        var thread = try std.Thread.spawn(
            .{ .allocator = self.allocator },
            otherpackage.Something.AsyncFn1,
            .{ something, self, state, AsyncCaller.callBack, AsyncCaller.callDeinit },
        );
        std.Thread.detach(thread);
    }

    // callBack
    // This runs in the same thread that fn callInit spawned.
    fn callBack(self_ptr: *anyopaque, state: *anyopaque, args: *CBArgsFn1) !void {
        var self: *AsyncCaller = @alignCast(@ptrCast(self_ptr));
        var self_state: *DoitState = @alignCast(@ptrCast(self_ptr));
        std.debug.print("AsyncCaller: i is {d}.", args.i);
        return;
    }

    fn callDeinit(self_ptr: *anyopaque, state_ptr: *anyopaque) void {
        var self: *AsyncCaller = @alignCast(@ptrCast(self_ptr));
        var state: *DoitState = @alignCast(@ptrCast(state_ptr));
        state.deinit();
    }

}
