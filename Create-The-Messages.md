## Messages are part of the kickzig framework

### kickzig offers 3 types of messages

1. The **Back to Front** message
   * the back-end sends information to the front-end.
   * the front-end processes the data
   * the front-end does not reply because the back-end messenger does not receive, it only sends.
   * The back-end messenger only sends when triggered from some other back-end module.
1. The **Front to Back to Front** message
   * the front-end sends a request to the back-end.
   * the back-end tries to fullfill the request.
   * the back-end sends the requested information or some other expected response or no response at all.
1. The **Back to Front & Front to Back to Front** message is a combination of the above 2 messages.

When kickzig adds a message it also adds a back-end messenger to handle the message.

## The RebuildContactList message

The RebuildContactList message contains a list of all of the contacts.
The RebuildContactList back-end messenger gets the list of contacts from the store and sends the list to the front-end. The back-end messenger only sends the list when triggered from some other back-end module.

```shell
＄ kickzig message add-bf RebuildContactList
Added the RebuildContactList message at /home/nil/zig/crud/src/deps/message/RebuildContactList.zig:1:1:
Added the back-end RebuildContactList messenger at /home/nil/zig/crud/src/backend/messenger/RebuildContactList.zig:1:1:
```

## The AddContact message

The AddContact message contains the new user created contact record.
The AddContact back-end messenger

1. Checks for user errors.
   * If there is a user error then sends the message back to the front-end with the user error message.
1. Adds the record to the store.
   * If there is an error then closes down the app by calling exit.
   * Otherwise
     * Returns the message with success information.
     * Triggers the RebuildContactList messenger.

```shell
＄ kickzig message add-fbf AddContact
Added the AddContact message at /home/nil/zig/crud/src/deps/message/AddContact.zig:1:1:
Added the back-end AddContact messenger at /home/nil/zig/crud/src/backend/messenger/AddContact.zig:1:1:
```

## The EditContact message

The EditContact message contains the user's edits to a contact record.

1. Checks for user errors.
   * If there is a user error then sends the message back to the front-end with the user error message.
1. Updates the record in the store.
   * If there is an error then closes down the app by calling exit.
   * Otherwise
     * Returns the message with success information.
     * Triggers the RebuildContactList messenger.

The EditContact back-end messenger updates the store with the user's edits to the record. Then the EditContact back-end messenger triggers the RebuildContactList messenger.

```shell
＄ kickzig message add-fbf EditContact
Added the EditContact message at /home/nil/zig/crud/src/deps/message/EditContact.zig:1:1:
Added the back-end EditContact messenger at /home/nil/zig/crud/src/backend/messenger/EditContact.zig:1:1:
```

## The RemoveContact message

The RemoveContact message contains the id of a contact record that the user wants removed.

1. Removes the record from the store.
   * If there is an error then closes down the app by calling exit.
   * Otherwise
     * Returns the message with success information.
     * Triggers the RebuildContactList messenger.

```shell
＄ kickzig message add-fbf RemoveContact
Added the RemoveContact message at /home/nil/zig/crud/src/deps/message/RemoveContact.zig:1:1:
Added the back-end RemoveContact messenger at /home/nil/zig/crud/src/backend/messenger/RemoveContact.zig:1:1:
```

## Step 2: Define the message payloads

## The RebuildContactList message and back-end handler

### RebuildContactList Message

The RebuildContactList message contains a list of all of the contacts in its backend_payload.

My only edits to the message file are for the frontend_payload.

* lines 14
* lines 24 - 29
* line 33
* lines 38 - 43
* line 53
* lines 57 - 82

```zig
  1 ⎥ /// This file was generated by kickzig when you added the "RebuildContactList" message.
  2 ⎥ /// This file will be removed by kickzig if you remove the "RebuildContactList" message.
  3 ⎥ /// The "RebuildContactList" message is:
  4 ⎥ /// * sent from the back-end to the front-end only.
  5 ⎥ /// The back-end will:
  6 ⎥ /// 1. init this message.
  7 ⎥ /// 2. set the back-end payload.
  8 ⎥ /// 3. send the message to the front-end.
  9 ⎥ /// The front-end:
 10 ⎥ /// 1. will receive the message and process the data in the back-end payload.
 11 ⎥ /// 2. WILL NOT RETURN THE MESSAGE TO THE BACK-END.
 12 ⎥ const std = @import("std");
 13 ⎥ const Counter = @import("counter").Counter;
 14 ⎥ const Contact = @import("record").List;
 15 ⎥ 
 16 ⎥ // BackendPayload is the "RebuildContactList" message from the back-end to the front-end.
 17 ⎥ /// KICKZIG TODO: Add your own back-end payload fields and methods.
 18 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 19 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 20 ⎥ pub const BackendPayload = struct {
 21 ⎥     allocator: std.mem.Allocator = undefined,
 22 ⎥     is_set: bool,
 23 ⎥ 
 24 ⎥     contacts: ?[]const *const Contact,
 25 ⎥ 
 26 ⎥     pub const Settings = struct {
 27 ⎥         contacts: ?[]const *const Contact,
 28 ⎥     };
 29 ⎥ 
 30 ⎥     fn init(allocator: std.mem.Allocator) !*BackendPayload {
 31 ⎥         var self: *BackendPayload = try allocator.create(BackendPayload);
 32 ⎥         self.allocator = allocator;
 33 ⎥         self.contacts = null;
 34 ⎥         return self;
 35 ⎥     }
 36 ⎥ 
 37 ⎥     fn deinit(self: *BackendPayload) void {
 38 ⎥         if (self.contacts) |contacts| {
 39 ⎥             for (contacts) |contact| {
 40 ⎥                 contact.deinit();
 41 ⎥             }
 42 ⎥             self.allocator.free(contacts);
 43 ⎥         }
 44 ⎥         self.allocator.destroy(self);
 45 ⎥     }
 46 ⎥ 
 47 ⎥     /// Returns an error if already set.
 48 ⎥     /// The caller owns the param values. fn set only copies values.
 49 ⎥     pub fn set(self: *BackendPayload, values: Settings) !void {
 50 ⎥         if (self.is_set) {
 51 ⎥             return error.RebuildContactListBackendPayloadAlreadySet;
 52 ⎥         }
 53 ⎥         self.contacts = try self.copyOfContacts(values.contacts);
 54 ⎥         self.is_set = true;
 55 ⎥     }
 56 ⎥ 
 57 ⎥     /// Returns a copy of the slice of contacts.
 58 ⎥     pub fn copyContacts(self: *BackendPayload) !?[]const *const Contact {
 59 ⎥         return self.copyOfContacts(self.contacts);
 60 ⎥     }
 61 ⎥ 
 62 ⎥     /// Returns a copy of the param src_contacts.
 63 ⎥     fn copyOfContacts(self: *BackendPayload, src_contacts: ?[]const *const Contact) !?[]*const Contact {
 64 ⎥         if (src_contacts) |contacts| {
 65 ⎥             var dest_contacts: []*const Contact = try self.allocator.alloc(*const Contact, contacts.len);
 66 ⎥             for (contacts, 0..) |contact, i| {
 67 ⎥                 dest_contacts[i] = contact.copy() catch |err| {
 68 ⎥                     for (dest_contacts, 0..) |deinit_contact, j| {
 69 ⎥                         if (j == i) {
 70 ⎥                             break;
 71 ⎥                         }
 72 ⎥                         deinit_contact.deinit();
 73 ⎥                     }
 74 ⎥                     self.allocator.free(dest_contacts);
 75 ⎥                     return err;
 76 ⎥                 };
 77 ⎥             }
 78 ⎥             return dest_contacts;
 79 ⎥         } else {
 80 ⎥             return null;
 81 ⎥         }
 82 ⎥     }
 83 ⎥ };
 84 ⎥ 
 85 ⎥ /// This is the "RebuildContactList" message.
 86 ⎥ pub const Message = struct {
 87 ⎥     allocator: std.mem.Allocator,
 88 ⎥     count_pointers: *Counter,
 89 ⎥     backend_payload: *BackendPayload,
 90 ⎥ 
 91 ⎥     // deinit does not deinit until self is the final pointer to Message.
 92 ⎥     pub fn deinit(self: *Message) void {
 93 ⎥         if (self.count_pointers.dec() > 0) {
 94 ⎥             // There are more pointers.
 95 ⎥             // See fn copy.
 96 ⎥             return;
 97 ⎥         }
 98 ⎥         // This is the last existing pointer.
 99 ⎥         self.count_pointers.deinit();
100 ⎥         self.allocator.destroy(self);
101 ⎥     }
102 ⎥ 
103 ⎥     /// KICKZIG TODO:
104 ⎥     /// copy pretends to create and return a copy of the message.
105 ⎥     /// The dispatcher sends a copy to each receiveFn.
106 ⎥     /// Each receiveFn owns the message copy and must deinit it.
107 ⎥     ///
108 ⎥     /// In this case copy does not return a copy of itself.
109 ⎥     /// In order to save memory space, it really only
110 ⎥     /// * increments the count of the number of pointers to this message.
111 ⎥     /// * returns self.
112 ⎥     /// See deinit().
113 ⎥     pub fn copy(self: *Message) !*Message {
114 ⎥         _ = self.count_pointers.inc();
115 ⎥         return self;
116 ⎥     }
117 ⎥ };
118 ⎥ 
119 ⎥ /// init creates an original message.
120 ⎥ pub fn init(allocator: std.mem.Allocator) !*Message {
121 ⎥     var self: *Message = try allocator.create(Message);
122 ⎥     self.count_pointers = try Counter.init(allocator);
123 ⎥     errdefer {
124 ⎥         allocator.destroy(self);
125 ⎥     }
126 ⎥     self.backend_payload = try BackendPayload.init(allocator);
127 ⎥     errdefer {
128 ⎥         allocator.destroy(self);
129 ⎥         self.count_pointers.deinit();
130 ⎥     }
131 ⎥     _ = self.count_pointers.inc();
132 ⎥     self.allocator = allocator;
133 ⎥     return self;
134 ⎥ }
135 ⎥ 
```

### RebuildContactList back-end messenger

The RebuildContactList back-end messenger gets the list of contacts from the store and sends the list to the front-end. It never does it on its own. It only sends the list when triggered from some other back-end module.

* backend/api.zig fn kickstart,
* by the AddContact back-end message handler,
* by the EditContact back-end message handler,
* by the RemoveContact back-end message handler.

My only edits to the messenger file are

* lines 11 & 13
* lines 21
* lines 53 - 65
* line 77

```zig
  1 ⎥ /// This is the back-end's "RebuildContactList" message handler.
  2 ⎥ /// This messenger must be triggered to send a default "RebuildContactList" message to the front-end.
  3 ⎥ /// The "RebuildContactList" message is at deps/message/src/RebuildContactList.zig.
  4 ⎥ /// This file was generated by kickzig when you added the "RebuildContactList" message.
  5 ⎥ /// This file will be removed by kickzig when you remove the "RebuildContactList" message.
  6 ⎥ const std = @import("std");
  7 ⎥ 
  8 ⎥ const _channel_ = @import("channel");
  9 ⎥ const _message_ = @import("message");
 10 ⎥ const _startup_ = @import("startup");
 11 ⎥ const Contact = @import("record").List;
 12 ⎥ const ExitFn = @import("various").ExitFn;
 13 ⎥ const Store = @import("store").Store;
 14 ⎥ 
 15 ⎥ pub const Messenger = struct {
 16 ⎥     allocator: std.mem.Allocator,
 17 ⎥     send_channels: *_channel_.BackendToFrontend,
 18 ⎥     receive_channels: *_channel_.FrontendToBackend,
 19 ⎥     triggers: *_channel_.Trigger,
 20 ⎥     exit: ExitFn,
 21 ⎥     store: *Store,
 22 ⎥ 
 23 ⎥     pub fn deinit(self: *Messenger) void {
 24 ⎥         self.allocator.destroy(self);
 25 ⎥     }
 26 ⎥ 
 27 ⎥     /// triggerRebuildContactListFn builds and sends the "RebuildContactList" message to the front-end.
 28 ⎥     /// It implements _channel_.FrontendToBackend.RebuildContactList.Behavior.triggerFn found in deps/channel/frontend/bf/RebuildContactList.zig.
 29 ⎥     /// The front-end must not send a response back with this message.
 30 ⎥     /// This messenger is not able to receive a RebuildContactList message.
 31 ⎥     pub fn triggerRebuildContactListFn(implementor: *anyopaque) anyerror!void {
 32 ⎥         var self: *Messenger = @alignCast(@ptrCast(implementor));
 33 ⎥ 
 34 ⎥         const message: *_message_.RebuildContactList.Message = self.triggerJob() catch |err| {
 35 ⎥             // Fatal error.
 36 ⎥             self.exit(@src(), err, "self.triggerJob()");
 37 ⎥             return err;
 38 ⎥         };
 39 ⎥         // Send the message back to the front-end.
 40 ⎥         // The sender owns the message so never deinit the message.
 41 ⎥         self.send_channels.RebuildContactList.send(message) catch |err| {
 42 ⎥             // Fatal error.
 43 ⎥             self.exit(@src(), err, "self.send_channels.RebuildContactList.send(message)");
 44 ⎥             return err;
 45 ⎥         };
 46 ⎥     }
 47 ⎥ 
 48 ⎥     /// triggerJob creates message to send to the front-end.
 49 ⎥     /// Returns the processed message or an error.
 50 ⎥     /// KICKZIG TODO: Add the required functionality.
 51 ⎥     fn triggerJob(self: *Messenger) !*_message_.RebuildContactList.Message {
 52 ⎥         var message: *_message_.RebuildContactList.Message = try _message_.RebuildContactList.init(self.allocator);
 53 ⎥         const contacts: ?[]const *const Contact = self.store.contact_table.getAll() catch |err| {
 54 ⎥             message.deinit();
 55 ⎥             return err;
 56 ⎥         };
 57 ⎥         defer {
 58 ⎥             if (contacts) |cc| {
 59 ⎥                 for (cc) |c| {
 60 ⎥                     c.deinit();
 61 ⎥                 }
 62 ⎥                 self.allocator.free(cc);
 63 ⎥             }
 64 ⎥         }
 65 ⎥         try message.backend_payload.set(.{ .contacts = contacts });
 66 ⎥         return message;
 67 ⎥     }
 68 ⎥ };
 69 ⎥ 
 70 ⎥ pub fn init(startup: _startup_.Backend) !*Messenger {
 71 ⎥     var messenger: *Messenger = try startup.allocator.create(Messenger);
 72 ⎥     messenger.allocator = startup.allocator;
 73 ⎥     messenger.send_channels = startup.send_channels;
 74 ⎥     messenger.receive_channels = startup.receive_channels;
 75 ⎥     messenger.triggers = startup.triggers;
 76 ⎥     messenger.exit = startup.exit;
 77 ⎥     messenger.store = startup.store.?;
 78 ⎥ 
 79 ⎥     // Subscribe to trigger-send the RebuildContactList message.
 80 ⎥     var trigger_behavior = try startup.triggers.RebuildContactList.?.initBehavior();
 81 ⎥     errdefer {
 82 ⎥         messenger.deinit();
 83 ⎥     }
 84 ⎥     trigger_behavior.implementor = messenger;
 85 ⎥     trigger_behavior.triggerFn = &Messenger.triggerRebuildContactListFn;
 86 ⎥     try startup.triggers.RebuildContactList.?.subscribe(trigger_behavior);
 87 ⎥     errdefer {
 88 ⎥         messenger.deinit();
 89 ⎥     }
 90 ⎥     return messenger;
 91 ⎥ }
 92 ⎥ 
```

## The AddContact message and back-end handler

### AddContact Message

The AddContact message contains the new user created contact record in the frontend_payload. The backend_payload only carries a user_error_message for when a user error occurs.

My only edits to the message file are for the frontend_payload.

* lines 21
* lines 31 - 35
* line 41
* lines 46 - 48
* lines 59 - 61

```zig
  1 ⎥ /// This file was generated by kickzig when you added the "AddContact" message.
  2 ⎥ /// This file will be removed by kickzig if you remove the "AddContact" message.
  3 ⎥ /// The "AddContact" message is:
  4 ⎥ /// * sent from the front-end to the back-end
  5 ⎥ /// * with the back-end possibly returning the message back to the front-end.
  6 ⎥ /// The front-end will:
  7 ⎥ /// 1. init this message.
  8 ⎥ /// 2. set the front-end payload.
  9 ⎥ /// 3. send the message to the back-end.
 10 ⎥ /// The back-end will:
 11 ⎥ /// 1. receive the message and do something with the data in the front-end payload.
 12 ⎥ /// 2. The back-end may also:
 13 ⎥ ///    i.   make a return copy.
 14 ⎥ ///    ii.  set the back-end payload.
 15 ⎥ ///    iii. send the return copy back to the front-end.
 16 ⎥ /// The front-end upon receiving the returned message:
 17 ⎥ ///    i.  will process the data in the back-end payload.
 18 ⎥ ///    ii. WILL NOT RETURN THE MESSAGE TO THE BACK-END.
 19 ⎥ const std = @import("std");
 20 ⎥ const Counter = @import("counter").Counter;
 21 ⎥ const Contact = @import("record").Add;
 22 ⎥ 
 23 ⎥ // FrontendPayload is the "AddContact" message from the front-end to the back-end.
 24 ⎥ /// KICKZIG TODO: Add your own front-end payload fields and methods.
 25 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 26 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 27 ⎥ pub const FrontendPayload = struct {
 28 ⎥     allocator: std.mem.Allocator,
 29 ⎥     is_set: bool,
 30 ⎥ 
 31 ⎥     contact: ?*const Contact,
 32 ⎥ 
 33 ⎥     pub const Settings = struct {
 34 ⎥         contact: ?*const Contact = null,
 35 ⎥     };
 36 ⎥ 
 37 ⎥     fn init(allocator: std.mem.Allocator) !*FrontendPayload {
 38 ⎥         var self: *FrontendPayload = try allocator.create(FrontendPayload);
 39 ⎥         self.allocator = allocator;
 40 ⎥         self.is_set = false;
 41 ⎥         self.contact = null;
 42 ⎥         return self;
 43 ⎥     }
 44 ⎥ 
 45 ⎥     fn deinit(self: *FrontendPayload) void {
 46 ⎥         if (self.contact) |contact| {
 47 ⎥             @constCast(contact).deinit();
 48 ⎥         }
 49 ⎥         self.allocator.destroy(self);
 50 ⎥     }
 51 ⎥ 
 52 ⎥     /// Returns an error if already set.
 53 ⎥     /// The caller owns the param values. fn set only copies values.
 54 ⎥     pub fn set(self: *FrontendPayload, values: Settings) !void {
 55 ⎥         if (self.is_set) {
 56 ⎥             return error.AddContactFrontendPayloadAlreadySet;
 57 ⎥         }
 58 ⎥         self.is_set = true;
 59 ⎥         if (values.contact) |contact| {
 60 ⎥             self.contact = try @constCast(contact).copy();
 61 ⎥         }
 62 ⎥     }
 63 ⎥ };
 64 ⎥ 
 65 ⎥ // BackendPayload is the "AddContact" message from the back-end to the front-end.
 66 ⎥ /// KICKZIG TODO: Add your own back-end payload fields and methods.
 67 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 68 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 69 ⎥ pub const BackendPayload = struct {
 70 ⎥     allocator: std.mem.Allocator = undefined,
 71 ⎥     is_set: bool,
 72 ⎥ 
 73 ⎥     // The member user_error_message is presented as an example.
 74 ⎥     user_error_message: ?[]const u8,
 75 ⎥ 
 76 ⎥     pub const Settings = struct {
 77 ⎥         user_error_message: ?[]const u8 = null,
 78 ⎥     };
 79 ⎥ 
 80 ⎥     fn init(allocator: std.mem.Allocator) !*BackendPayload {
 81 ⎥         var self: *BackendPayload = try allocator.create(BackendPayload);
 82 ⎥         self.allocator = allocator;
 83 ⎥         self.user_error_message = null;
 84 ⎥         return self;
 85 ⎥     }
 86 ⎥ 
 87 ⎥     fn deinit(self: *BackendPayload) void {
 88 ⎥         if (self.user_error_message) |user_error_message| {
 89 ⎥             self.allocator.free(user_error_message);
 90 ⎥         }
 91 ⎥         self.allocator.destroy(self);
 92 ⎥     }
 93 ⎥ 
 94 ⎥     /// Returns an error if already set.
 95 ⎥     /// The caller owns the param values. fn set only copies values.
 96 ⎥     pub fn set(self: *BackendPayload, values: Settings) !void {
 97 ⎥         if (self.is_set) {
 98 ⎥             return error.AddContactBackendPayloadAlreadySet;
 99 ⎥         }
100 ⎥         self.is_set = true;
101 ⎥         if (values.user_error_message) |user_error_message| {
102 ⎥             self.user_error_message = try self.allocator.alloc(u8, user_error_message.len);
103 ⎥             @memcpy(@constCast(self.user_error_message.?), user_error_message);
104 ⎥         }
105 ⎥     }
106 ⎥ };
107 ⎥ 
108 ⎥ /// This is the "AddContact" message.
109 ⎥ pub const Message = struct {
110 ⎥     allocator: std.mem.Allocator,
111 ⎥     count_pointers: *Counter,
112 ⎥     frontend_payload: *FrontendPayload,
113 ⎥     backend_payload: *BackendPayload,
114 ⎥ 
115 ⎥     // deinit does not deinit until self is the final pointer to Message.
116 ⎥     pub fn deinit(self: *Message) void {
117 ⎥         if (self.count_pointers.dec() > 0) {
118 ⎥             // There are more pointers.
119 ⎥             // See fn copy.
120 ⎥             return;
121 ⎥         }
122 ⎥         // This is the last existing pointer.
123 ⎥         self.count_pointers.deinit();
124 ⎥         self.allocator.destroy(self);
125 ⎥     }
126 ⎥ 
127 ⎥     /// KICKZIG TODO:
128 ⎥     /// copy pretends to create and return a copy of the message.
129 ⎥     /// The dispatcher sends a copy to each receiveFn.
130 ⎥     /// Each receiveFn owns the message copy and must deinit it.
131 ⎥     /// The back-end receiveFn must only send a copy to the front-end.
132 ⎥     /// Back-end Messenger Example:
133 ⎥     /// var return_copy = message.copy() catch |err| {
134 ⎥     ///     self.exit(@src(), err, "message.copy()");
135 ⎥     /// };
136 ⎥     /// // Set the back-end payload.
137 ⎥     /// return_copy.backend_payload.set(.{.name = record.name}) catch |err| {
138 ⎥     ///     self.exit(@src(), err, "return_copy.backend_payload.set(.{.name = record.name})");
139 ⎥     /// };
140 ⎥     /// // Send the message copy to the front-end.
141 ⎥     /// // The channel's send function owns the copy and will deinit it.
142 ⎥     /// self.send_channels.AddContact.send(message) catch |err| {
143 ⎥     ///     self.exit(@src(), err, "self.send_channels.AddContact.send(message)");
144 ⎥     /// };
145 ⎥     ///
146 ⎥     /// In this case copy does not return a copy of itself.
147 ⎥     /// In order to save memory space, it really only
148 ⎥     /// * increments the count of the number of pointers to this message.
149 ⎥     /// * returns self.
150 ⎥     /// See deinit().
151 ⎥     pub fn copy(self: *Message) !*Message {
152 ⎥         _ = self.count_pointers.inc();
153 ⎥         return self;
154 ⎥     }
155 ⎥ };
156 ⎥ 
157 ⎥ /// init creates an original message.
158 ⎥ pub fn init(allocator: std.mem.Allocator) !*Message {
159 ⎥     var self: *Message = try allocator.create(Message);
160 ⎥     self.frontend_payload = try FrontendPayload.init(allocator);
161 ⎥     errdefer {
162 ⎥         allocator.destroy(self);
163 ⎥     }
164 ⎥     self.backend_payload = try BackendPayload.init(allocator);
165 ⎥     errdefer {
166 ⎥         self.frontend_payload.deinit();
167 ⎥         allocator.destroy(self);
168 ⎥     }
169 ⎥     self.count_pointers = try Counter.init(allocator);
170 ⎥     errdefer {
171 ⎥         self.backend_payload.deinit();
172 ⎥         self.frontend_payload.deinit();
173 ⎥         allocator.destroy(self);
174 ⎥     }
175 ⎥     _ = self.count_pointers.inc();
176 ⎥     self.allocator = allocator;
177 ⎥     return self;
178 ⎥ }
179 ⎥ 
```

### AddContact back-end messenger

The AddContact back-end messenger adds the new user created contact record to the store. Then the AddContact back-end messenger triggers the RebuildContactList messenger.

My only edits to the messenger file are

* line 14
* line 22
* lines 46 - 51
* lines 57 - 92
* line 103

```zig
  1 ⎥ /// This is the back-end's "AddContact" message handler.
  2 ⎥ /// This messenger can receive the "AddContact" message from the front-end
  3 ⎥ ///     and then if needed, send the "AddContact" message back to the front-end.
  4 ⎥ /// The "AddContact" message is at deps/message/src/AddContact.zig.
  5 ⎥ /// This file was generated by kickzig when you added the "AddContact" message.
  6 ⎥ /// This file will be removed by kickzig when you remove the "AddContact" message.
  7 ⎥ /// KICKZIG TODO: Customize fn receiveFn.
  8 ⎥ const std = @import("std");
  9 ⎥ 
 10 ⎥ const _channel_ = @import("channel");
 11 ⎥ const _message_ = @import("message");
 12 ⎥ const _startup_ = @import("startup");
 13 ⎥ const ExitFn = @import("various").ExitFn;
 14 ⎥ const Store = @import("store").Store;
 15 ⎥ 
 16 ⎥ pub const Messenger = struct {
 17 ⎥     allocator: std.mem.Allocator,
 18 ⎥     send_channels: *_channel_.BackendToFrontend,
 19 ⎥     receive_channels: *_channel_.FrontendToBackend,
 20 ⎥     triggers: *_channel_.Trigger,
 21 ⎥     exit: ExitFn,
 22 ⎥     store: *Store,
 23 ⎥ 
 24 ⎥     pub fn deinit(self: *Messenger) void {
 25 ⎥         self.allocator.destroy(self);
 26 ⎥     }
 27 ⎥ 
 28 ⎥     /// receiveAddContactFn receives the "AddContact" message from the front-end.
 29 ⎥     /// It implements _channel_.FrontendToBackend.AddContact.Behavior.receiveFn found in deps/channel/fronttoback/AddContact.zig.
 30 ⎥     /// The receiveAddContactFn owns the message it receives.
 31 ⎥     pub fn receiveAddContactFn(implementor: *anyopaque, message: *_message_.AddContact.Message) anyerror!void {
 32 ⎥         var self: *Messenger = @alignCast(@ptrCast(implementor));
 33 ⎥         defer message.deinit();
 34 ⎥ 
 35 ⎥         self.receiveJob(message) catch |err| {
 36 ⎥             // Fatal error.
 37 ⎥             self.exit(@src(), err, "self.receiveJob(message)");
 38 ⎥             return err;
 39 ⎥         };
 40 ⎥         // Send the send the reply to the front-end if required.
 41 ⎥         self.send_channels.AddContact.send(message) catch |err| {
 42 ⎥             // Fatal error.
 43 ⎥             self.exit(@src(), err, "self.send_channels.AddContact.send(message)");
 44 ⎥             return err;
 45 ⎥         };
 46 ⎥         if (message.backend_payload.user_error_message.?.len == 0) {
 47 ⎥             // There are no warnings for the user so the record was added.
 48 ⎥             // The stored data has changed with the added record.
 49 ⎥             // Start new lists.
 50 ⎥             try self.triggers.RebuildContactList.trigger();
 51 ⎥         }
 52 ⎥     }
 53 ⎥ 
 54 ⎥     /// receiveJob fullfills the front-end's request.
 55 ⎥     /// Returns nothing or an error.
 56 ⎥     fn receiveJob(self: *Messenger, message: *_message_.AddContact.Message) !void {
 57 ⎥         if (message.frontend_payload.contact) |contact| {
 58 ⎥             if (contact.name == null) {
 59 ⎥                 try message.backend_payload.set(
 60 ⎥                     .{ .user_error_message = "Name is a required field." },
 61 ⎥                 );
 62 ⎥                 return;
 63 ⎥             }
 64 ⎥             if (contact.address == null) {
 65 ⎥                 try message.backend_payload.set(
 66 ⎥                     .{ .user_error_message = "Address is a required field." },
 67 ⎥                 );
 68 ⎥                 return;
 69 ⎥             }
 70 ⎥             if (contact.city == null) {
 71 ⎥                 try message.backend_payload.set(
 72 ⎥                     .{ .user_error_message = "City is a required field." },
 73 ⎥                 );
 74 ⎥                 return;
 75 ⎥             }
 76 ⎥             if (contact.state == null) {
 77 ⎥                 try message.backend_payload.set(
 78 ⎥                     .{ .user_error_message = "State is a required field." },
 79 ⎥                 );
 80 ⎥                 return;
 81 ⎥             }
 82 ⎥             if (contact.zip == null) {
 83 ⎥                 try message.backend_payload.set(
 84 ⎥                     .{ .user_error_message = "Zip is a required field." },
 85 ⎥                 );
 86 ⎥                 return;
 87 ⎥             }
 88 ⎥             // Store the record.
 89 ⎥             try self.store.contact_table.add(contact.name.?, contact.address.?, contact.city.?, contact.state.?, contact.zip.?);
 90 ⎥         } else {
 91 ⎥             return error.AddContactMessageMissingContact;
 92 ⎥         }
 93 ⎥     }
 94 ⎥ };
 95 ⎥ 
 96 ⎥ pub fn init(startup: _startup_.Backend) !*Messenger {
 97 ⎥     var messenger: *Messenger = try startup.allocator.create(Messenger);
 98 ⎥     messenger.allocator = startup.allocator;
 99 ⎥     messenger.send_channels = startup.send_channels;
100 ⎥     messenger.receive_channels = startup.receive_channels;
101 ⎥     messenger.triggers = startup.triggers;
102 ⎥     messenger.exit = startup.exit;
103 ⎥     messenger.store = startup.store;
104 ⎥ 
105 ⎥     // Subscribe to receive the AddContact message.
106 ⎥     var receive_behavior = try startup.receive_channels.AddContact.initBehavior();
107 ⎥     errdefer {
108 ⎥         messenger.deinit();
109 ⎥     }
110 ⎥     receive_behavior.implementor = messenger;
111 ⎥     receive_behavior.receiveFn = &Messenger.receiveAddContactFn;
112 ⎥     try startup.receive_channels.AddContact.subscribe(receive_behavior);
113 ⎥     errdefer {
114 ⎥         messenger.deinit();
115 ⎥     }
116 ⎥ 
117 ⎥     return messenger;
118 ⎥ }
119 ⎥ 
```

## The EditContact message and back-end messenger

### EditContact message

The EditContact message contains the user's edits to a contact record. The backend_payload only carries a user_error_message for when a user error occurs.

My only edits to the message file are for the frontend_payload.

* lines 21
* lines 31 - 35
* line 41
* lines 46 - 48
* lines 59 - 61

```zig
  1 ⎥ /// This file was generated by kickzig when you added the "EditContact" message.
  2 ⎥ /// This file will be removed by kickzig if you remove the "EditContact" message.
  3 ⎥ /// The "EditContact" message is:
  4 ⎥ /// * sent from the front-end to the back-end
  5 ⎥ /// * with the back-end possibly returning the message back to the front-end.
  6 ⎥ /// The front-end will:
  7 ⎥ /// 1. init this message.
  8 ⎥ /// 2. set the front-end payload.
  9 ⎥ /// 3. send the message to the back-end.
 10 ⎥ /// The back-end will:
 11 ⎥ /// 1. receive the message and do something with the data in the front-end payload.
 12 ⎥ /// 2. The back-end may also:
 13 ⎥ ///    i.   make a return copy.
 14 ⎥ ///    ii.  set the back-end payload.
 15 ⎥ ///    iii. send the return copy back to the front-end.
 16 ⎥ /// The front-end upon receiving the returned message:
 17 ⎥ ///    i.  will process the data in the back-end payload.
 18 ⎥ ///    ii. WILL NOT RETURN THE MESSAGE TO THE BACK-END.
 19 ⎥ const std = @import("std");
 20 ⎥ const Counter = @import("counter").Counter;
 21 ⎥ const Contact = @import("record").Edit;
 22 ⎥ 
 23 ⎥ // FrontendPayload is the "EditContact" message from the front-end to the back-end.
 24 ⎥ /// KICKZIG TODO: Add your own front-end payload fields and methods.
 25 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 26 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 27 ⎥ pub const FrontendPayload = struct {
 28 ⎥     allocator: std.mem.Allocator,
 29 ⎥     is_set: bool,
 30 ⎥ 
 31 ⎥     contact: ?*const Contact,
 32 ⎥ 
 33 ⎥     pub const Settings = struct {
 34 ⎥         contact: ?*const Contact = null,
 35 ⎥     };
 36 ⎥ 
 37 ⎥     fn init(allocator: std.mem.Allocator) !*FrontendPayload {
 38 ⎥         var self: *FrontendPayload = try allocator.create(FrontendPayload);
 39 ⎥         self.allocator = allocator;
 40 ⎥         self.is_set = false;
 41 ⎥         self.contact = null;
 42 ⎥         return self;
 43 ⎥     }
 44 ⎥ 
 45 ⎥     fn deinit(self: *FrontendPayload) void {
 46 ⎥         if (self.contact) |contact| {
 47 ⎥             @constCast(contact).deinit();
 48 ⎥         }
 49 ⎥         self.allocator.destroy(self);
 50 ⎥     }
 51 ⎥ 
 52 ⎥     /// Returns an error if already set.
 53 ⎥     /// The caller owns the param values. fn set only copies values.
 54 ⎥     pub fn set(self: *FrontendPayload, values: Settings) !void {
 55 ⎥         if (self.is_set) {
 56 ⎥             return error.EditContactFrontendPayloadAlreadySet;
 57 ⎥         }
 58 ⎥         self.is_set = true;
 59 ⎥         if (values.contact) |contact| {
 60 ⎥             self.contact = try @constCast(contact).copy();
 61 ⎥         }
 62 ⎥     }
 63 ⎥ };
 64 ⎥ 
 65 ⎥ // BackendPayload is the "EditContact" message from the back-end to the front-end.
 66 ⎥ /// KICKZIG TODO: Add your own back-end payload fields and methods.
 67 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 68 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 69 ⎥ pub const BackendPayload = struct {
 70 ⎥     allocator: std.mem.Allocator = undefined,
 71 ⎥     is_set: bool,
 72 ⎥ 
 73 ⎥     // The member user_error_message is presented as an example.
 74 ⎥     user_error_message: ?[]const u8,
 75 ⎥ 
 76 ⎥     pub const Settings = struct {
 77 ⎥         user_error_message: ?[]const u8 = null,
 78 ⎥     };
 79 ⎥ 
 80 ⎥     fn init(allocator: std.mem.Allocator) !*BackendPayload {
 81 ⎥         var self: *BackendPayload = try allocator.create(BackendPayload);
 82 ⎥         self.allocator = allocator;
 83 ⎥         self.user_error_message = null;
 84 ⎥         return self;
 85 ⎥     }
 86 ⎥ 
 87 ⎥     fn deinit(self: *BackendPayload) void {
 88 ⎥         if (self.user_error_message) |user_error_message| {
 89 ⎥             self.allocator.free(user_error_message);
 90 ⎥         }
 91 ⎥         self.allocator.destroy(self);
 92 ⎥     }
 93 ⎥ 
 94 ⎥     /// Returns an error if already set.
 95 ⎥     /// The caller owns the param values. fn set only copies values.
 96 ⎥     pub fn set(self: *BackendPayload, values: Settings) !void {
 97 ⎥         if (self.is_set) {
 98 ⎥             return error.EditContactBackendPayloadAlreadySet;
 99 ⎥         }
100 ⎥         self.is_set = true;
101 ⎥         if (values.user_error_message) |user_error_message| {
102 ⎥             self.user_error_message = try self.allocator.alloc(u8, user_error_message.len);
103 ⎥             @memcpy(@constCast(self.user_error_message.?), user_error_message);
104 ⎥         }
105 ⎥     }
106 ⎥ };
107 ⎥ 
108 ⎥ /// This is the "EditContact" message.
109 ⎥ pub const Message = struct {
110 ⎥     allocator: std.mem.Allocator,
111 ⎥     count_pointers: *Counter,
112 ⎥     frontend_payload: *FrontendPayload,
113 ⎥     backend_payload: *BackendPayload,
114 ⎥ 
115 ⎥     // deinit does not deinit until self is the final pointer to Message.
116 ⎥     pub fn deinit(self: *Message) void {
117 ⎥         if (self.count_pointers.dec() > 0) {
118 ⎥             // There are more pointers.
119 ⎥             // See fn copy.
120 ⎥             return;
121 ⎥         }
122 ⎥         // This is the last existing pointer.
123 ⎥         self.count_pointers.deinit();
124 ⎥         self.allocator.destroy(self);
125 ⎥     }
126 ⎥ 
127 ⎥     /// KICKZIG TODO:
128 ⎥     /// copy pretends to create and return a copy of the message.
129 ⎥     /// The dispatcher sends a copy to each receiveFn.
130 ⎥     /// Each receiveFn owns the message copy and must deinit it.
131 ⎥     /// The back-end receiveFn must only send a copy to the front-end.
132 ⎥     /// Back-end Messenger Example:
133 ⎥     /// var return_copy = message.copy() catch |err| {
134 ⎥     ///     self.exit(@src(), err, "message.copy()");
135 ⎥     /// };
136 ⎥     /// // Set the back-end payload.
137 ⎥     /// return_copy.backend_payload.set(.{.name = record.name}) catch |err| {
138 ⎥     ///     self.exit(@src(), err, "return_copy.backend_payload.set(.{.name = record.name})");
139 ⎥     /// };
140 ⎥     /// // Send the message copy to the front-end.
141 ⎥     /// // The channel's send function owns the copy and will deinit it.
142 ⎥     /// self.send_channels.EditContact.send(message) catch |err| {
143 ⎥     ///     self.exit(@src(), err, "self.send_channels.EditContact.send(message)");
144 ⎥     /// };
145 ⎥     ///
146 ⎥     /// In this case copy does not return a copy of itself.
147 ⎥     /// In order to save memory space, it really only
148 ⎥     /// * increments the count of the number of pointers to this message.
149 ⎥     /// * returns self.
150 ⎥     /// See deinit().
151 ⎥     pub fn copy(self: *Message) !*Message {
152 ⎥         _ = self.count_pointers.inc();
153 ⎥         return self;
154 ⎥     }
155 ⎥ };
156 ⎥ 
157 ⎥ /// init creates an original message.
158 ⎥ pub fn init(allocator: std.mem.Allocator) !*Message {
159 ⎥     var self: *Message = try allocator.create(Message);
160 ⎥     self.frontend_payload = try FrontendPayload.init(allocator);
161 ⎥     errdefer {
162 ⎥         allocator.destroy(self);
163 ⎥     }
164 ⎥     self.backend_payload = try BackendPayload.init(allocator);
165 ⎥     errdefer {
166 ⎥         self.frontend_payload.deinit();
167 ⎥         allocator.destroy(self);
168 ⎥     }
169 ⎥     self.count_pointers = try Counter.init(allocator);
170 ⎥     errdefer {
171 ⎥         self.backend_payload.deinit();
172 ⎥         self.frontend_payload.deinit();
173 ⎥         allocator.destroy(self);
174 ⎥     }
175 ⎥     _ = self.count_pointers.inc();
176 ⎥     self.allocator = allocator;
177 ⎥     return self;
178 ⎥ }
179 ⎥ 
```

### EditContact back-end messenger

The EditContact back-end messenger updates the store with the user's edits to the record. Then the EditContact back-end messenger triggers the RebuildContactList messenger.

My only edits to the messenger file are

* line 14
* line 22
* lines 53 - 57
* lines 64 - 110
* line 121

```zig
  1 ⎥ /// This is the back-end's "EditContact" message handler.
  2 ⎥ /// This messenger can receive the "EditContact" message from the front-end
  3 ⎥ ///     and then if needed, send the "EditContact" message back to the front-end.
  4 ⎥ /// The "EditContact" message is at deps/message/src/EditContact.zig.
  5 ⎥ /// This file was generated by kickzig when you added the "EditContact" message.
  6 ⎥ /// This file will be removed by kickzig when you remove the "EditContact" message.
  7 ⎥ /// KICKZIG TODO: Customize fn receiveFn.
  8 ⎥ const std = @import("std");
  9 ⎥ 
 10 ⎥ const _channel_ = @import("channel");
 11 ⎥ const _message_ = @import("message");
 12 ⎥ const _startup_ = @import("startup");
 13 ⎥ const ExitFn = @import("various").ExitFn;
 14 ⎥ const Store = @import("store").Store;
 15 ⎥ 
 16 ⎥ pub const Messenger = struct {
 17 ⎥     allocator: std.mem.Allocator,
 18 ⎥     send_channels: *_channel_.BackendToFrontend,
 19 ⎥     receive_channels: *_channel_.FrontendToBackend,
 20 ⎥     triggers: *_channel_.Trigger,
 21 ⎥     exit: ExitFn,
 22 ⎥     store: *Store,
 23 ⎥ 
 24 ⎥     pub fn deinit(self: *Messenger) void {
 25 ⎥         self.allocator.destroy(self);
 26 ⎥     }
 27 ⎥ 
 28 ⎥     /// receiveEditContactFn receives the "EditContact" message from the front-end.
 29 ⎥     /// It implements _channel_.FrontendToBackend.EditContact.Behavior.receiveFn found in deps/channel/fronttoback/EditContact.zig.
 30 ⎥     /// The receiveEditContactFn owns the message it receives.
 31 ⎥     pub fn receiveEditContactFn(implementor: *anyopaque, message: *_message_.EditContact.Message) anyerror!void {
 32 ⎥         var self: *Messenger = @alignCast(@ptrCast(implementor));
 33 ⎥         defer message.deinit();
 34 ⎥ 
 35 ⎥         self.receiveJob(message) catch |err| {
 36 ⎥             // Fatal error.
 37 ⎥             self.exit(@src(), err, "self.receiveJob(message)");
 38 ⎥             return err;
 39 ⎥         };
 40 ⎥         // If required, send a copy of the message back.
 41 ⎥         // Send a copy of the message back to the front-end.
 42 ⎥         // The channel owns the message so never deinit the message.
 43 ⎥         const copy = message.copy() catch |err| {
 44 ⎥             // Fatal error.
 45 ⎥             self.exit(@src(), err, "message.copy()");
 46 ⎥             return err;
 47 ⎥         };
 48 ⎥         self.send_channels.EditContact.send(copy) catch |err| {
 49 ⎥             // Fatal error.
 50 ⎥             self.exit(@src(), err, "self.send_channels.EditContact.send(message)");
 51 ⎥             return err;
 52 ⎥         };
 53 ⎥         if (message.backend_payload.user_error_message == null) {
 54 ⎥             // No error message for the user so the record was added.
 55 ⎥             // The select list must reload.
 56 ⎥             try self.triggers.RebuildContactList.?.trigger();
 57 ⎥         }
 58 ⎥     }
 59 ⎥ 
 60 ⎥     /// receiveJob fullfills the front-end's request.
 61 ⎥     /// Returns nothing or an error.
 62 ⎥     /// KICKZIG TODO: Add the required functionality.
 63 ⎥     fn receiveJob(self: *Messenger, message: *_message_.EditContact.Message) !void {
 64 ⎥         if (message.frontend_payload.contact) |contact| {
 65 ⎥             if (contact.id == 0) {
 66 ⎥                 try message.backend_payload.set(
 67 ⎥                     .{ .user_error_message = "ID is a required field." },
 68 ⎥                 );
 69 ⎥                 return;
 70 ⎥             }
 71 ⎥             if (contact.name == null) {
 72 ⎥                 try message.backend_payload.set(
 73 ⎥                     .{ .user_error_message = "Name is a required field." },
 74 ⎥                 );
 75 ⎥                 return;
 76 ⎥             }
 77 ⎥ 
 78 ⎥             if (contact.address == null) {
 79 ⎥                 try message.backend_payload.set(
 80 ⎥                     .{ .user_error_message = "Address is a required field." },
 81 ⎥                 );
 82 ⎥                 return;
 83 ⎥             }
 84 ⎥ 
 85 ⎥             if (contact.city == null) {
 86 ⎥                 try message.backend_payload.set(
 87 ⎥                     .{ .user_error_message = "City is a required field." },
 88 ⎥                 );
 89 ⎥                 return;
 90 ⎥             }
 91 ⎥ 
 92 ⎥             if (contact.state == null) {
 93 ⎥                 try message.backend_payload.set(
 94 ⎥                     .{ .user_error_message = "State is a required field." },
 95 ⎥                 );
 96 ⎥                 return;
 97 ⎥             }
 98 ⎥ 
 99 ⎥             if (contact.zip == null) {
100 ⎥                 try message.backend_payload.set(
101 ⎥                     .{ .user_error_message = "Zip is a required field." },
102 ⎥                 );
103 ⎥                 return;
104 ⎥             }
105 ⎥ 
106 ⎥             // Store the record.
107 ⎥             try self.store.contact_table.update(contact.id, contact.name.?, contact.address.?, contact.city.?, contact.state.?, contact.zip.?);
108 ⎥         } else {
109 ⎥             return error.EditContactMessageMissingContact;
110 ⎥         }
111 ⎥     }
112 ⎥ };
113 ⎥ 
114 ⎥ pub fn init(startup: _startup_.Backend) !*Messenger {
115 ⎥     var messenger: *Messenger = try startup.allocator.create(Messenger);
116 ⎥     messenger.allocator = startup.allocator;
117 ⎥     messenger.send_channels = startup.send_channels;
118 ⎥     messenger.receive_channels = startup.receive_channels;
119 ⎥     messenger.triggers = startup.triggers;
120 ⎥     messenger.exit = startup.exit;
121 ⎥     messenger.store = startup.store.?;
122 ⎥ 
123 ⎥     // Subscribe to receive the EditContact message.
124 ⎥     var receive_behavior = try startup.receive_channels.EditContact.initBehavior();
125 ⎥     errdefer {
126 ⎥         messenger.deinit();
127 ⎥     }
128 ⎥     receive_behavior.implementor = messenger;
129 ⎥     receive_behavior.receiveFn = &Messenger.receiveEditContactFn;
130 ⎥     try startup.receive_channels.EditContact.subscribe(receive_behavior);
131 ⎥     errdefer {
132 ⎥         messenger.deinit();
133 ⎥     }
134 ⎥     return messenger;
135 ⎥ }
136 ⎥ 
```

## The RemoveContact message and back-end messenger

### RemoveContact message

The RemoveContact message contains the id of a contact record that the user wants removed. That id is contained in the message's frontend_payload which is set by the front-end. The backend_payload only carries a user_error_message for when a user error occurs.

My only edits to the message file are for the frontend_payload.

* lines 21
* lines 31 - 36
* line 41
* lines 46 - 48
* lines 58 - 60

```zig
  1 ⎥ /// This file was generated by kickzig when you added the "RemoveContact" message.
  2 ⎥ /// This file will be removed by kickzig if you remove the "RemoveContact" message.
  3 ⎥ /// The "RemoveContact" message is:
  4 ⎥ /// * sent from the front-end to the back-end
  5 ⎥ /// * with the back-end possibly returning the message back to the front-end.
  6 ⎥ /// The front-end will:
  7 ⎥ /// 1. init this message.
  8 ⎥ /// 2. set the front-end payload.
  9 ⎥ /// 3. send the message to the back-end.
 10 ⎥ /// The back-end will:
 11 ⎥ /// 1. receive the message and do something with the data in the front-end payload.
 12 ⎥ /// 2. The back-end may also:
 13 ⎥ ///    i.   make a return copy.
 14 ⎥ ///    ii.  set the back-end payload.
 15 ⎥ ///    iii. send the return copy back to the front-end.
 16 ⎥ /// The front-end upon receiving the returned message:
 17 ⎥ ///    i.  will process the data in the back-end payload.
 18 ⎥ ///    ii. WILL NOT RETURN THE MESSAGE TO THE BACK-END.
 19 ⎥ const std = @import("std");
 20 ⎥ const Counter = @import("counter").Counter;
 21 ⎥ const Contact = @import("record").Remove;
 22 ⎥ 
 23 ⎥ // FrontendPayload is the "RemoveContact" message from the front-end to the back-end.
 24 ⎥ /// KICKZIG TODO: Add your own front-end payload fields and methods.
 25 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 26 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 27 ⎥ pub const FrontendPayload = struct {
 28 ⎥     allocator: std.mem.Allocator,
 29 ⎥     is_set: bool,
 30 ⎥ 
 31 ⎥     contact: ?*const Contact,
 32 ⎥ 
 33 ⎥     pub const Settings = struct {
 34 ⎥         contact: ?*const Contact = null,
 35 ⎥     };
 36 ⎥ 
 37 ⎥     fn init(allocator: std.mem.Allocator) !*FrontendPayload {
 38 ⎥         var self: *FrontendPayload = try allocator.create(FrontendPayload);
 39 ⎥         self.allocator = allocator;
 40 ⎥         self.is_set = false;
 41 ⎥         self.contact = null;
 42 ⎥         return self;
 43 ⎥     }
 44 ⎥ 
 45 ⎥     fn deinit(self: *FrontendPayload) void {
 46 ⎥         if (self.contact) |contact| {
 47 ⎥             @constCast(contact).deinit();
 48 ⎥         }
 49 ⎥         self.allocator.destroy(self);
 50 ⎥     }
 51 ⎥ 
 52 ⎥     /// Returns an error if already set.
 53 ⎥     /// The caller owns the param values. fn set only copies values.
 54 ⎥     pub fn set(self: *FrontendPayload, values: Settings) !void {
 55 ⎥         if (self.is_set) {
 56 ⎥             return error.RemoveContactFrontendPayloadAlreadySet;
 57 ⎥         }
 58 ⎥         if (values.contact) |contact| {
 59 ⎥             self.contact = try @constCast(contact).copy();
 60 ⎥         }
 61 ⎥     }
 62 ⎥ };
 63 ⎥ 
 64 ⎥ // BackendPayload is the "RemoveContact" message from the back-end to the front-end.
 65 ⎥ /// KICKZIG TODO: Add your own back-end payload fields and methods.
 66 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 67 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 68 ⎥ pub const BackendPayload = struct {
 69 ⎥     allocator: std.mem.Allocator = undefined,
 70 ⎥     is_set: bool,
 71 ⎥ 
 72 ⎥     // The member user_error_message is presented as an example.
 73 ⎥     user_error_message: ?[]const u8,
 74 ⎥ 
 75 ⎥     pub const Settings = struct {
 76 ⎥         user_error_message: ?[]const u8 = null,
 77 ⎥     };
 78 ⎥ 
 79 ⎥     fn init(allocator: std.mem.Allocator) !*BackendPayload {
 80 ⎥         var self: *BackendPayload = try allocator.create(BackendPayload);
 81 ⎥         self.allocator = allocator;
 82 ⎥         self.user_error_message = null;
 83 ⎥         return self;
 84 ⎥     }
 85 ⎥ 
 86 ⎥     fn deinit(self: *BackendPayload) void {
 87 ⎥         if (self.user_error_message) |user_error_message| {
 88 ⎥             self.allocator.free(user_error_message);
 89 ⎥         }
 90 ⎥         self.allocator.destroy(self);
 91 ⎥     }
 92 ⎥ 
 93 ⎥     /// Returns an error if already set.
 94 ⎥     /// The caller owns the param values. fn set only copies values.
 95 ⎥     pub fn set(self: *BackendPayload, values: Settings) !void {
 96 ⎥         if (self.is_set) {
 97 ⎥             return error.RemoveContactBackendPayloadAlreadySet;
 98 ⎥         }
 99 ⎥         self.is_set = true;
100 ⎥         if (values.user_error_message) |user_error_message| {
101 ⎥             self.user_error_message = try self.allocator.alloc(u8, user_error_message.len);
102 ⎥             @memcpy(@constCast(self.user_error_message.?), user_error_message);
103 ⎥         }
104 ⎥     }
105 ⎥ };
106 ⎥ 
107 ⎥ /// This is the "RemoveContact" message.
108 ⎥ pub const Message = struct {
109 ⎥     allocator: std.mem.Allocator,
110 ⎥     count_pointers: *Counter,
111 ⎥     frontend_payload: *FrontendPayload,
112 ⎥     backend_payload: *BackendPayload,
113 ⎥ 
114 ⎥     // deinit does not deinit until self is the final pointer to Message.
115 ⎥     pub fn deinit(self: *Message) void {
116 ⎥         if (self.count_pointers.dec() > 0) {
117 ⎥             // There are more pointers.
118 ⎥             // See fn copy.
119 ⎥             return;
120 ⎥         }
121 ⎥         // This is the last existing pointer.
122 ⎥         self.count_pointers.deinit();
123 ⎥         self.allocator.destroy(self);
124 ⎥     }
125 ⎥ 
126 ⎥     /// KICKZIG TODO:
127 ⎥     /// copy pretends to create and return a copy of the message.
128 ⎥     /// The dispatcher sends a copy to each receiveFn.
129 ⎥     /// Each receiveFn owns the message copy and must deinit it.
130 ⎥     /// The back-end receiveFn must only send a copy to the front-end.
131 ⎥     /// Back-end Messenger Example:
132 ⎥     /// var return_copy = message.copy() catch |err| {
133 ⎥     ///     self.exit(@src(), err, "message.copy()");
134 ⎥     /// };
135 ⎥     /// // Set the back-end payload.
136 ⎥     /// return_copy.backend_payload.set(.{.name = record.name}) catch |err| {
137 ⎥     ///     self.exit(@src(), err, "return_copy.backend_payload.set(.{.name = record.name})");
138 ⎥     /// };
139 ⎥     /// // Send the message copy to the front-end.
140 ⎥     /// // The channel's send function owns the copy and will deinit it.
141 ⎥     /// self.send_channels.RemoveContact.send(message) catch |err| {
142 ⎥     ///     self.exit(@src(), err, "self.send_channels.RemoveContact.send(message)");
143 ⎥     /// };
144 ⎥     ///
145 ⎥     /// In this case copy does not return a copy of itself.
146 ⎥     /// In order to save memory space, it really only
147 ⎥     /// * increments the count of the number of pointers to this message.
148 ⎥     /// * returns self.
149 ⎥     /// See deinit().
150 ⎥     pub fn copy(self: *Message) !*Message {
151 ⎥         _ = self.count_pointers.inc();
152 ⎥         return self;
153 ⎥     }
154 ⎥ };
155 ⎥ 
156 ⎥ /// init creates an original message.
157 ⎥ pub fn init(allocator: std.mem.Allocator) !*Message {
158 ⎥     var self: *Message = try allocator.create(Message);
159 ⎥     self.frontend_payload = try FrontendPayload.init(allocator);
160 ⎥     errdefer {
161 ⎥         allocator.destroy(self);
162 ⎥     }
163 ⎥     self.backend_payload = try BackendPayload.init(allocator);
164 ⎥     errdefer {
165 ⎥         self.frontend_payload.deinit();
166 ⎥         allocator.destroy(self);
167 ⎥     }
168 ⎥     self.count_pointers = try Counter.init(allocator);
169 ⎥     errdefer {
170 ⎥         self.backend_payload.deinit();
171 ⎥         self.frontend_payload.deinit();
172 ⎥         allocator.destroy(self);
173 ⎥     }
174 ⎥     _ = self.count_pointers.inc();
175 ⎥     self.allocator = allocator;
176 ⎥     return self;
177 ⎥ }
178 ⎥ 
```

### RemoveContact back-end messenger

The RemoveContact back-end messenger removes the user selected contact record from the store.

My only edits to the messenger file are

* line 14
* line 22
* lines 53 - 57
* lines 64 - 68
* line 79

```zig
  1 ⎥ /// This is the back-end's "RemoveContact" message handler.
  2 ⎥ /// This messenger can receive the "RemoveContact" message from the front-end
  3 ⎥ ///     and then if needed, send the "RemoveContact" message back to the front-end.
  4 ⎥ /// The "RemoveContact" message is at deps/message/src/RemoveContact.zig.
  5 ⎥ /// This file was generated by kickzig when you added the "RemoveContact" message.
  6 ⎥ /// This file will be removed by kickzig when you remove the "RemoveContact" message.
  7 ⎥ /// KICKZIG TODO: Customize fn receiveFn.
  8 ⎥ const std = @import("std");
  9 ⎥ 
 10 ⎥ const _channel_ = @import("channel");
 11 ⎥ const _message_ = @import("message");
 12 ⎥ const _startup_ = @import("startup");
 13 ⎥ const ExitFn = @import("various").ExitFn;
 14 ⎥ const Store = @import("store").Store;
 15 ⎥ 
 16 ⎥ pub const Messenger = struct {
 17 ⎥     allocator: std.mem.Allocator,
 18 ⎥     send_channels: *_channel_.BackendToFrontend,
 19 ⎥     receive_channels: *_channel_.FrontendToBackend,
 20 ⎥     triggers: *_channel_.Trigger,
 21 ⎥     exit: ExitFn,
 22 ⎥     store: *Store,
 23 ⎥ 
 24 ⎥     pub fn deinit(self: *Messenger) void {
 25 ⎥         self.allocator.destroy(self);
 26 ⎥     }
 27 ⎥ 
 28 ⎥     /// receiveRemoveContactFn receives the "RemoveContact" message from the front-end.
 29 ⎥     /// It implements _channel_.FrontendToBackend.RemoveContact.Behavior.receiveFn found in deps/channel/fronttoback/RemoveContact.zig.
 30 ⎥     /// The receiveRemoveContactFn owns the message it receives.
 31 ⎥     pub fn receiveRemoveContactFn(implementor: *anyopaque, message: *_message_.RemoveContact.Message) anyerror!void {
 32 ⎥         var self: *Messenger = @alignCast(@ptrCast(implementor));
 33 ⎥         defer message.deinit();
 34 ⎥ 
 35 ⎥         self.receiveJob(message) catch |err| {
 36 ⎥             // Fatal error.
 37 ⎥             self.exit(@src(), err, "self.receiveJob(message)");
 38 ⎥             return err;
 39 ⎥         };
 40 ⎥         // If required, send a copy of the message back.
 41 ⎥         // Send a copy of the message back to the front-end.
 42 ⎥         // The channel owns the message so never deinit the message.
 43 ⎥         const copy = message.copy() catch |err| {
 44 ⎥             // Fatal error.
 45 ⎥             self.exit(@src(), err, "message.copy()");
 46 ⎥             return err;
 47 ⎥         };
 48 ⎥         self.send_channels.RemoveContact.send(copy) catch |err| {
 49 ⎥             // Fatal error.
 50 ⎥             self.exit(@src(), err, "self.send_channels.RemoveContact.send(message)");
 51 ⎥             return err;
 52 ⎥         };
 53 ⎥         if (message.backend_payload.user_error_message == null) {
 54 ⎥             // No error message for the user so the record was added.
 55 ⎥             // The select list must reload.
 56 ⎥             try self.triggers.RebuildContactList.?.trigger();
 57 ⎥         }
 58 ⎥     }
 59 ⎥ 
 60 ⎥     /// receiveJob fullfills the front-end's request.
 61 ⎥     /// Returns nothing or an error.
 62 ⎥     /// KICKZIG TODO: Add the required functionality.
 63 ⎥     fn receiveJob(self: *Messenger, message: *_message_.RemoveContact.Message) !void {
 64 ⎥         if (message.frontend_payload.contact) |contact| {
 65 ⎥             return self.store.contact_table.remove(contact.id);
 66 ⎥         } else {
 67 ⎥             return error.RebuildContactListMessageMissingContact;
 68 ⎥         }
 69 ⎥     }
 70 ⎥ };
 71 ⎥ 
 72 ⎥ pub fn init(startup: _startup_.Backend) !*Messenger {
 73 ⎥     var messenger: *Messenger = try startup.allocator.create(Messenger);
 74 ⎥     messenger.allocator = startup.allocator;
 75 ⎥     messenger.send_channels = startup.send_channels;
 76 ⎥     messenger.receive_channels = startup.receive_channels;
 77 ⎥     messenger.triggers = startup.triggers;
 78 ⎥     messenger.exit = startup.exit;
 79 ⎥     messenger.store = startup.store.?;
 80 ⎥ 
 81 ⎥     // Subscribe to receive the RemoveContact message.
 82 ⎥     var receive_behavior = try startup.receive_channels.RemoveContact.initBehavior();
 83 ⎥     errdefer {
 84 ⎥         messenger.deinit();
 85 ⎥     }
 86 ⎥     receive_behavior.implementor = messenger;
 87 ⎥     receive_behavior.receiveFn = &Messenger.receiveRemoveContactFn;
 88 ⎥     try startup.receive_channels.RemoveContact.subscribe(receive_behavior);
 89 ⎥     errdefer {
 90 ⎥         messenger.deinit();
 91 ⎥     }
 92 ⎥     return messenger;
 93 ⎥ }
 94 ⎥ 
 ```

## Next

[[Kickstarting The Backend|Kickstarting-The-Backend]]
