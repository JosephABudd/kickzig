## Messages are part of the kickzig framework

### kickzig offers 3 types of messages

1. The **Back to Front** message
   * the back-end sends information to the front-end.
   * the front-end processes the data
   * the front-end does not reply because the back-end messenger does not receive, it only sends.
   * The back-end messenger only sends when triggered from some other back-end module.
1. The **Front to Back to Front** message
   * the front-end sends a request to the back-end.
   * the back-end tries to fullfill the request.
   * the back-end sends the requested information or some other expected response or no response at all.
1. The **Back to Front & Front to Back to Front** message is a combination of the above 2 messages.

When kickzig adds a message it also adds a back-end messenger to handle the message.

## The RebuildContactList message

The RebuildContactList message contains a list of all of the contacts.
The RebuildContactList back-end messenger gets the list of contacts from the store and sends the list to the front-end. The back-end messenger only sends the list when triggered from some other back-end module.

```shell
＄ kickzig message add-bf RebuildContactList
Added the RebuildContactList message at /home/nil/zig/crud/src/@This/deps/message/RebuildContactList.zig:1:1:
Added the back-end RebuildContactList messenger at /home/nil/zig/crud/src/@This/backend/messenger/RebuildContactList.zig:1:1:
```

## The AddContact message

The AddContact message contains the new user created contact record.
The AddContact back-end messenger adds the new user created contact record to the store. Then the AddContact back-end messenger triggers the RebuildContactList messenger.

```shell
＄ kickzig message add-fbf AddContact
Added the AddContact message at /home/nil/zig/crud/src/@This/deps/message/AddContact.zig:1:1:
Added the back-end AddContact messenger at /home/nil/zig/crud/src/@This/backend/messenger/AddContact.zig:1:1:
```

## The EditContact message

The EditContact message contains the user's edits to a contact record.
The EditContact back-end messenger updates the store with the user's edits to the record. Then the EditContact back-end messenger triggers the RebuildContactList messenger.

```shell
＄ kickzig message add-fbf EditContact
Added the EditContact message at /home/nil/zig/crud/src/@This/deps/message/EditContact.zig:1:1:
Added the back-end EditContact messenger at /home/nil/zig/crud/src/@This/backend/messenger/EditContact.zig:1:1:
```

## The RemoveContact message

The RemoveContact message contains the id of a contact record that the user wants removed.
The RemoveContact back-end messenger removes the user selected contact record from the store. Then the RemoveContact back-end messenger triggers the RebuildContactList messenger.

```shell
＄ kickzig message add-fbf RemoveContact
Added the RemoveContact message at /home/nil/zig/crud/src/@This/deps/message/RemoveContact.zig:1:1:
Added the back-end RemoveContact messenger at /home/nil/zig/crud/src/@This/backend/messenger/RemoveContact.zig:1:1:
```

## Step 2: Define the message payloads

## The RebuildContactList message and back-end handler

### RebuildContactList Message

The RebuildContactList message contains a list of all of the contacts in its backend_payload.

My only edits to the message file are for the frontend_payload.

* lines 14
* lines 24 - 29
* line 34
* lines 39 - 44
* lines 55 - 57

```zig
  1 ⎥ /// This file was generated by kickzig when you added the "RebuildContactList" message.
  2 ⎥ /// This file will be removed by kickzig if you remove the "RebuildContactList" message.
  3 ⎥ /// The "RebuildContactList" message is:
  4 ⎥ /// * sent from the back-end to the front-end only.
  5 ⎥ /// The back-end will:
  6 ⎥ /// 1. init this message.
  7 ⎥ /// 2. set the back-end payload.
  8 ⎥ /// 3. send the message to the front-end.
  9 ⎥ /// The front-end:
 10 ⎥ /// 1. will receive the message and process the data in the back-end payload.
 11 ⎥ /// 2. WILL NOT RETURN THE MESSAGE TO THE BACK-END.
 12 ⎥ const std = @import("std");
 13 ⎥ const Counter = @import("counter").Counter;
 14 ⎥ const Contact = @import("record").List;
 15 ⎥ 
 16 ⎥ // BackendPayload is the "RebuildContactList" message from the back-end to the front-end.
 17 ⎥ /// KICKZIG TODO: Add your own back-end payload fields and methods.
 18 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 19 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 20 ⎥ pub const BackendPayload = struct {
 21 ⎥     allocator: std.mem.Allocator = undefined,
 22 ⎥     is_set: bool,
 23 ⎥ 
 24 ⎥     // The member foofoo is presented as an example.
 25 ⎥     contacts: ?[]const *const Contact,
 26 ⎥ 
 27 ⎥     pub const Settings = struct {
 28 ⎥         contacts: ?[]const *const Contact,
 29 ⎥     };
 30 ⎥ 
 31 ⎥     fn init(allocator: std.mem.Allocator) !*BackendPayload {
 32 ⎥         var self: *BackendPayload = try allocator.create(BackendPayload);
 33 ⎥         self.allocator = allocator;
 34 ⎥         self.contacts = null;
 35 ⎥         return self;
 36 ⎥     }
 37 ⎥ 
 38 ⎥     fn deinit(self: *BackendPayload) void {
 39 ⎥         if (self.contacts) |contacts| {
 40 ⎥             for (contacts) |contact| {
 41 ⎥                 contact.deinit();
 42 ⎥             }
 43 ⎥             self.allocator.free(contacts);
 44 ⎥         }
 45 ⎥         self.allocator.destroy(self);
 46 ⎥     }
 47 ⎥ 
 48 ⎥     // Returns an error if already set.
 49 ⎥     // Parameter values.contacts is owned by set.
 50 ⎥     pub fn set(self: *BackendPayload, values: Settings) !void {
 51 ⎥         if (self.is_set) {
 52 ⎥             return error.RebuildContactListBackendPayloadAlreadySet;
 53 ⎥         }
 54 ⎥         self.is_set = true;
 55 ⎥         if (values.contacts) |contacts| {
 56 ⎥             self.contacts = contacts;
 57 ⎥         }
 58 ⎥     }
 59 ⎥ 
 60 ⎥     pub fn copyContacts(self: *BackendPayload) !?[]const *const Contact {
 61 ⎥         if (self.contacts) |contacts| {
 62 ⎥             var copy_contacts: []const *const Contact = try self.allocator.alloc(*const Contact, contacts.len);
 63 ⎥             for (contacts, 0..) |contact, i| {
 64 ⎥                 @constCast(copy_contacts)[i] = try contact.copy();
 65 ⎥             }
 66 ⎥             return copy_contacts;
 67 ⎥         } else {
 68 ⎥             return null;
 69 ⎥         }
 70 ⎥     }
 71 ⎥ };
 72 ⎥ 
 73 ⎥ /// This is the "RebuildContactList" message.
 74 ⎥ pub const Message = struct {
 75 ⎥     allocator: std.mem.Allocator,
 76 ⎥     count_pointers: *Counter,
 77 ⎥     backend_payload: *BackendPayload,
 78 ⎥ 
 79 ⎥     // deinit does not deinit until self is the final pointer to Message.
 80 ⎥     pub fn deinit(self: *Message) void {
 81 ⎥         if (self.count_pointers.dec() > 0) {
 82 ⎥             // There are more pointers.
 83 ⎥             // See fn copy.
 84 ⎥             return;
 85 ⎥         }
 86 ⎥         // This is the last existing pointer.
 87 ⎥         self.allocator.destroy(self);
 88 ⎥     }
 89 ⎥ 
 90 ⎥     /// KICKZIG TODO:
 91 ⎥     /// copy pretends to create and return a copy of the message.
 92 ⎥     /// The dispatcher sends a copy to each receiveFn.
 93 ⎥     /// Each receiveFn owns the message copy and must deinit it.
 94 ⎥     ///
 95 ⎥     /// In this case copy does not return a copy of itself.
 96 ⎥     /// In order to save memory space, it really only
 97 ⎥     /// * increments the count of the number of pointers to this message.
 98 ⎥     /// * returns self.
 99 ⎥     /// See deinit().
100 ⎥     pub fn copy(self: *Message) !*Message {
101 ⎥         _ = self.count_pointers.inc();
102 ⎥         return self;
103 ⎥     }
104 ⎥ };
105 ⎥ 
106 ⎥ /// init creates an original message.
107 ⎥ pub fn init(allocator: std.mem.Allocator) !*Message {
108 ⎥     var self: *Message = try allocator.create(Message);
109 ⎥     self.count_pointers = try Counter.init(allocator);
110 ⎥     errdefer {
111 ⎥         allocator.destroy(self);
112 ⎥     }
113 ⎥     self.backend_payload = try BackendPayload.init(allocator);
114 ⎥     errdefer {
115 ⎥         allocator.destroy(self);
116 ⎥         self.count_pointers.deinit();
117 ⎥     }
118 ⎥     _ = self.count_pointers.inc();
119 ⎥     self.allocator = allocator;
120 ⎥     return self;
121 ⎥ }
122 ⎥ 
```

### RebuildContactList back-end messenger

The RebuildContactList back-end messenger gets the list of contacts from the store and sends the list to the front-end. It never does it on its own. It only sends the list when triggered from some other back-end module.

* backend/api.zig fn kickstart,
* by the AddContact back-end message handler,
* by the EditContact back-end message handler,
* by the RemoveContact back-end message handler.

My only edits to the messenger file are

* lines 12 - 13
* lines 21
* lines 53 - 61
* line 72

```zig
  1 ⎥ /// This is the back-end's "RebuildContactList" message handler.
  2 ⎥ /// This messenger must be triggered to send a default "RebuildContactList" message to the front-end.
  3 ⎥ /// The "RebuildContactList" message is at deps/message/src/RebuildContactList.zig.
  4 ⎥ /// This file was generated by kickzig when you added the "RebuildContactList" message.
  5 ⎥ /// This file will be removed by kickzig when you remove the "RebuildContactList" message.
  6 ⎥ const std = @import("std");
  7 ⎥ 
  8 ⎥ const _channel_ = @import("channel");
  9 ⎥ const _message_ = @import("message");
 10 ⎥ const _startup_ = @import("startup");
 11 ⎥ const ExitFn = @import("various").ExitFn;
 12 ⎥ const Store = @import("store").Store;
 13 ⎥ const Contact = @import("record").List;
 14 ⎥ 
 15 ⎥ pub const Messenger = struct {
 16 ⎥     allocator: std.mem.Allocator,
 17 ⎥     send_channels: *_channel_.BackendToFrontend,
 18 ⎥     receive_channels: *_channel_.FrontendToBackend,
 19 ⎥     triggers: *_channel_.Trigger,
 20 ⎥     exit: ExitFn,
 21 ⎥     store: *Store,
 22 ⎥ 
 23 ⎥     pub fn deinit(self: *Messenger) void {
 24 ⎥         self.allocator.destroy(self);
 25 ⎥     }
 26 ⎥ 
 27 ⎥     /// triggerRebuildContactListFn builds and sends the "RebuildContactList" message to the front-end.
 28 ⎥     /// It implements _channel_.FrontendToBackend.RebuildContactList.Behavior.triggerFn found in deps/channel/frontend/bf/RebuildContactList.zig.
 29 ⎥     /// The front-end must not send a response back with this message.
 30 ⎥     /// This messenger is not able to receive a RebuildContactList message.
 31 ⎥     pub fn triggerRebuildContactListFn(implementor: *anyopaque) ?anyerror {
 32 ⎥         var self: *Messenger = @alignCast(@ptrCast(implementor));
 33 ⎥ 
 34 ⎥         var message: *_message_.RebuildContactList.Message = self.triggerJob() catch |err| {
 35 ⎥             // Fatal error.
 36 ⎥             self.exit(@src(), err, "self.triggerJob()");
 37 ⎥             return err;
 38 ⎥         };
 39 ⎥         // Send the message back to the front-end.
 40 ⎥         // The sender owns the message so never deinit the message.
 41 ⎥         self.send_channels.RebuildContactList.send(message) catch |err| {
 42 ⎥             // Fatal error.
 43 ⎥             self.exit(@src(), err, "self.send_channels.RebuildContactList.send(message)");
 44 ⎥             return err;
 45 ⎥         };
 46 ⎥         // No errors so return null;
 47 ⎥         return null;
 48 ⎥     }
 49 ⎥ 
 50 ⎥     /// triggerJob creates message to send to the front-end.
 51 ⎥     /// Returns the processed message or an error.
 52 ⎥     fn triggerJob(self: *Messenger) !*_message_.RebuildContactList.Message {
 53 ⎥         var message: *_message_.RebuildContactList.Message = try _message_.RebuildContactList.init(self.allocator);
 54 ⎥         var contacts: ?[]const *const Contact = self.store.contact_table.getAll() catch |err| {
 55 ⎥             return err;
 56 ⎥         };
 57 ⎥         errdefer {
 58 ⎥             message.deinit();
 59 ⎥         }
 60 ⎥         try message.backend_payload.set(.{ .contacts = contacts });
 61 ⎥         return message;
 62 ⎥     }
 63 ⎥ };
 64 ⎥ 
 65 ⎥ pub fn init(startup: _startup_.Backend) !*Messenger {
 66 ⎥     var messenger: *Messenger = try startup.allocator.create(Messenger);
 67 ⎥     messenger.allocator = startup.allocator;
 68 ⎥     messenger.send_channels = startup.send_channels;
 69 ⎥     messenger.receive_channels = startup.receive_channels;
 70 ⎥     messenger.triggers = startup.triggers;
 71 ⎥     messenger.exit = startup.exit;
 72 ⎥     messenger.store = startup.store;
 73 ⎥ 
 74 ⎥     // Subscribe to trigger-send the RemoveContact message.
 75 ⎥     var trigger_behavior = try startup.triggers.RebuildContactList.initBehavior();
 76 ⎥     errdefer {
 77 ⎥         messenger.deinit();
 78 ⎥     }
 79 ⎥     trigger_behavior.implementor = messenger;
 80 ⎥     trigger_behavior.triggerFn = &Messenger.triggerRebuildContactListFn;
 81 ⎥     try startup.triggers.RebuildContactList.subscribe(trigger_behavior);
 82 ⎥     errdefer {
 83 ⎥         messenger.deinit();
 84 ⎥     }
 85 ⎥ 
 86 ⎥     return messenger;
 87 ⎥ }
 88 ⎥ 
```

## The AddContact message and back-end handler

### AddContact Message

The AddContact message contains the new user created contact record in the frontend_payload. The backend_payload only carries a user_error_message for when a user error occurs.

My only edits to the message file are for the frontend_payload.

* lines 21
* lines 31 - 36
* line 42
* lines 47 - 49
* lines 60 - 62

```zig
  1 ⎥ /// This file was generated by kickzig when you added the "AddContact" message.
  2 ⎥ /// This file will be removed by kickzig if you remove the "AddContact" message.
  3 ⎥ /// The "AddContact" message is:
  4 ⎥ /// * sent from the front-end to the back-end
  5 ⎥ /// * with the back-end possibly returning the message back to the front-end.
  6 ⎥ /// The front-end will:
  7 ⎥ /// 1. init this message.
  8 ⎥ /// 2. set the front-end payload.
  9 ⎥ /// 3. send the message to the back-end.
 10 ⎥ /// The back-end will:
 11 ⎥ /// 1. receive the message and do something with the data in the front-end payload.
 12 ⎥ /// 2. The back-end may also:
 13 ⎥ ///    i.   make a return copy.
 14 ⎥ ///    ii.  set the back-end payload.
 15 ⎥ ///    iii. send the return copy back to the front-end.
 16 ⎥ /// The front-end upon receiving the returned message:
 17 ⎥ ///    i.  will process the data in the back-end payload.
 18 ⎥ ///    ii. WILL NOT RETURN THE MESSAGE TO THE BACK-END.
 19 ⎥ const std = @import("std");
 20 ⎥ const Counter = @import("counter").Counter;
 21 ⎥ const Contact = @import("record").Add;
 22 ⎥ 
 23 ⎥ // FrontendPayload is the "AddContact" message from the front-end to the back-end.
 24 ⎥ /// KICKZIG TODO: Add your own front-end payload fields and methods.
 25 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 26 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 27 ⎥ pub const FrontendPayload = struct {
 28 ⎥     allocator: std.mem.Allocator,
 29 ⎥     is_set: bool,
 30 ⎥ 
 31 ⎥     // The member contact is the contact the user has added.
 32 ⎥     contact: ?*const Contact,
 33 ⎥ 
 34 ⎥     pub const Settings = struct {
 35 ⎥         contact: ?*const Contact = null,
 36 ⎥     };
 37 ⎥ 
 38 ⎥     fn init(allocator: std.mem.Allocator) !*FrontendPayload {
 39 ⎥         var self: *FrontendPayload = try allocator.create(FrontendPayload);
 40 ⎥         self.allocator = allocator;
 41 ⎥         self.is_set = false;
 42 ⎥         self.contact = null;
 43 ⎥         return self;
 44 ⎥     }
 45 ⎥ 
 46 ⎥     fn deinit(self: *FrontendPayload) void {
 47 ⎥         if (self.contact) |contact| {
 48 ⎥             @constCast(contact).deinit();
 49 ⎥         }
 50 ⎥         self.allocator.destroy(self);
 51 ⎥     }
 52 ⎥ 
 53 ⎥     // Returns an error if already set.
 54 ⎥     // Parameter values.contact is owned by FrontendPayload.
 55 ⎥     pub fn set(self: *FrontendPayload, values: Settings) !void {
 56 ⎥         if (self.is_set) {
 57 ⎥             return error.AddContactFrontendPayloadAlreadySet;
 58 ⎥         }
 59 ⎥         self.is_set = true;
 60 ⎥         if (values.contact) |contact| {
 61 ⎥             self.contact = contact;
 62 ⎥         }
 63 ⎥     }
 64 ⎥ };
 65 ⎥ 
 66 ⎥ // BackendPayload is the "AddContact" message from the back-end to the front-end.
 67 ⎥ /// KICKZIG TODO: Add your own back-end payload fields and methods.
 68 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 69 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 70 ⎥ pub const BackendPayload = struct {
 71 ⎥     allocator: std.mem.Allocator = undefined,
 72 ⎥     is_set: bool,
 73 ⎥ 
 74 ⎥     // The member user_error_message is presented as an example.
 75 ⎥     user_error_message: ?[]const u8,
 76 ⎥ 
 77 ⎥     pub const Settings = struct {
 78 ⎥         user_error_message: ?[]const u8,
 79 ⎥     };
 80 ⎥ 
 81 ⎥     fn init(allocator: std.mem.Allocator) !*BackendPayload {
 82 ⎥         var self: *BackendPayload = try allocator.create(BackendPayload);
 83 ⎥         self.allocator = allocator;
 84 ⎥         self.user_error_message = null;
 85 ⎥         return self;
 86 ⎥     }
 87 ⎥ 
 88 ⎥     fn deinit(self: *BackendPayload) void {
 89 ⎥         if (self.user_error_message) |user_error_message| {
 90 ⎥             self.allocator.free(user_error_message);
 91 ⎥         }
 92 ⎥         self.allocator.destroy(self);
 93 ⎥     }
 94 ⎥ 
 95 ⎥     // Returns an error if already set.
 96 ⎥     pub fn set(self: *BackendPayload, values: Settings) !void {
 97 ⎥         if (self.is_set) {
 98 ⎥             return error.AddContactBackendPayloadAlreadySet;
 99 ⎥         }
100 ⎥         self.is_set = true;
101 ⎥         if (values.user_error_message) |user_error_message| {
102 ⎥             self.user_error_message = try self.allocator.alloc(u8, user_error_message.len);
103 ⎥             @memcpy(@constCast(self.user_error_message), user_error_message);
104 ⎥         }
105 ⎥     }
106 ⎥ };
107 ⎥ 
108 ⎥ /// This is the "AddContact" message.
109 ⎥ pub const Message = struct {
110 ⎥     allocator: std.mem.Allocator,
111 ⎥     count_pointers: *Counter,
112 ⎥     frontend_payload: *FrontendPayload,
113 ⎥     backend_payload: *BackendPayload,
114 ⎥ 
115 ⎥     // deinit does not deinit until self is the final pointer to Message.
116 ⎥     pub fn deinit(self: *Message) void {
117 ⎥         if (self.count_pointers.dec() > 0) {
118 ⎥             // There are more pointers.
119 ⎥             // See fn copy.
120 ⎥             return;
121 ⎥         }
122 ⎥         // This is the last existing pointer.
123 ⎥         self.allocator.destroy(self);
124 ⎥     }
125 ⎥ 
126 ⎥     /// KICKZIG TODO:
127 ⎥     /// copy pretends to create and return a copy of the message.
128 ⎥     /// The dispatcher sends a copy to each receiveFn.
129 ⎥     /// Each receiveFn owns the message copy and must deinit it.
130 ⎥     /// The back-end receiveFn must only send a copy to the front-end.
131 ⎥     /// Back-end Messenger Example:
132 ⎥     /// var return_copy = message.copy() catch |err| {
133 ⎥     ///     self.exit(@src(), err, "message.copy()");
134 ⎥     /// };
135 ⎥     /// // Set the back-end payload.
136 ⎥     /// return_copy.backend_payload.set(.{.name = record.name}) catch |err| {
137 ⎥     ///     self.exit(@src(), err, "return_copy.backend_payload.set(.{.name = record.name})");
138 ⎥     /// };
139 ⎥     /// // Send the message copy to the front-end.
140 ⎥     /// // The channel's send function owns the copy and will deinit it.
141 ⎥     /// self.send_channels.AddContact.send(message) catch |err| {
142 ⎥     ///     self.exit(@src(), err, "self.send_channels.AddContact.send(message)");
143 ⎥     /// };
144 ⎥     ///
145 ⎥     /// In this case copy does not return a copy of itself.
146 ⎥     /// In order to save memory space, it really only
147 ⎥     /// * increments the count of the number of pointers to this message.
148 ⎥     /// * returns self.
149 ⎥     /// See deinit().
150 ⎥     pub fn copy(self: *Message) !*Message {
151 ⎥         _ = self.count_pointers.inc();
152 ⎥         return self;
153 ⎥     }
154 ⎥ };
155 ⎥ 
156 ⎥ /// init creates an original message.
157 ⎥ pub fn init(allocator: std.mem.Allocator) !*Message {
158 ⎥     var self: *Message = try allocator.create(Message);
159 ⎥     self.frontend_payload = try FrontendPayload.init(allocator);
160 ⎥     errdefer {
161 ⎥         allocator.destroy(self);
162 ⎥     }
163 ⎥     self.backend_payload = try BackendPayload.init(allocator);
164 ⎥     errdefer {
165 ⎥         self.frontend_payload.deinit();
166 ⎥         allocator.destroy(self);
167 ⎥     }
168 ⎥     self.count_pointers = try Counter.init(allocator);
169 ⎥     errdefer {
170 ⎥         self.backend_payload.deinit();
171 ⎥         self.frontend_payload.deinit();
172 ⎥         allocator.destroy(self);
173 ⎥     }
174 ⎥     _ = self.count_pointers.inc();
175 ⎥     self.allocator = allocator;
176 ⎥     return self;
177 ⎥ }
178 ⎥ 
```

### AddContact back-end messenger

The AddContact back-end messenger adds the new user created contact record to the store. Then the AddContact back-end messenger triggers the RebuildContactList messenger.

My only edits to the messenger file are

* line 14
* line 22
* lines 46 - 51
* lines 57 - 92
* line 103

```zig
  1 ⎥ /// This is the back-end's "AddContact" message handler.
  2 ⎥ /// This messenger can receive the "AddContact" message from the front-end
  3 ⎥ ///     and then if needed, send the "AddContact" message back to the front-end.
  4 ⎥ /// The "AddContact" message is at deps/message/src/AddContact.zig.
  5 ⎥ /// This file was generated by kickzig when you added the "AddContact" message.
  6 ⎥ /// This file will be removed by kickzig when you remove the "AddContact" message.
  7 ⎥ /// KICKZIG TODO: Customize fn receiveFn.
  8 ⎥ const std = @import("std");
  9 ⎥ 
 10 ⎥ const _channel_ = @import("channel");
 11 ⎥ const _message_ = @import("message");
 12 ⎥ const _startup_ = @import("startup");
 13 ⎥ const ExitFn = @import("various").ExitFn;
 14 ⎥ const Store = @import("store").Store;
 15 ⎥ 
 16 ⎥ pub const Messenger = struct {
 17 ⎥     allocator: std.mem.Allocator,
 18 ⎥     send_channels: *_channel_.BackendToFrontend,
 19 ⎥     receive_channels: *_channel_.FrontendToBackend,
 20 ⎥     triggers: *_channel_.Trigger,
 21 ⎥     exit: ExitFn,
 22 ⎥     store: *Store,
 23 ⎥ 
 24 ⎥     pub fn deinit(self: *Messenger) void {
 25 ⎥         self.allocator.destroy(self);
 26 ⎥     }
 27 ⎥ 
 28 ⎥     /// receiveAddContactFn receives the "AddContact" message from the front-end.
 29 ⎥     /// It implements _channel_.FrontendToBackend.AddContact.Behavior.receiveFn found in deps/channel/fronttoback/AddContact.zig.
 30 ⎥     /// The receiveAddContactFn owns the message it receives.
 31 ⎥     pub fn receiveAddContactFn(implementor: *anyopaque, message: *_message_.AddContact.Message) anyerror!void {
 32 ⎥         var self: *Messenger = @alignCast(@ptrCast(implementor));
 33 ⎥         defer message.deinit();
 34 ⎥ 
 35 ⎥         self.receiveJob(message) catch |err| {
 36 ⎥             // Fatal error.
 37 ⎥             self.exit(@src(), err, "self.receiveJob(message)");
 38 ⎥             return err;
 39 ⎥         };
 40 ⎥         // Send the send the reply to the front-end if required.
 41 ⎥         self.send_channels.AddContact.send(message) catch |err| {
 42 ⎥             // Fatal error.
 43 ⎥             self.exit(@src(), err, "self.send_channels.AddContact.send(message)");
 44 ⎥             return err;
 45 ⎥         };
 46 ⎥         if (message.backend_payload.user_error_message.?.len == 0) {
 47 ⎥             // There are no warnings for the user so the record was added.
 48 ⎥             // The stored data has changed with the added record.
 49 ⎥             // Start new lists.
 50 ⎥             try self.triggers.RebuildContactList.trigger();
 51 ⎥         }
 52 ⎥     }
 53 ⎥ 
 54 ⎥     /// receiveJob fullfills the front-end's request.
 55 ⎥     /// Returns nothing or an error.
 56 ⎥     fn receiveJob(self: *Messenger, message: *_message_.AddContact.Message) !void {
 57 ⎥         if (message.frontend_payload.contact) |contact| {
 58 ⎥             if (contact.name == null) {
 59 ⎥                 try message.backend_payload.set(
 60 ⎥                     .{ .user_error_message = "Name is a required field." },
 61 ⎥                 );
 62 ⎥                 return;
 63 ⎥             }
 64 ⎥             if (contact.address == null) {
 65 ⎥                 try message.backend_payload.set(
 66 ⎥                     .{ .user_error_message = "Address is a required field." },
 67 ⎥                 );
 68 ⎥                 return;
 69 ⎥             }
 70 ⎥             if (contact.city == null) {
 71 ⎥                 try message.backend_payload.set(
 72 ⎥                     .{ .user_error_message = "City is a required field." },
 73 ⎥                 );
 74 ⎥                 return;
 75 ⎥             }
 76 ⎥             if (contact.state == null) {
 77 ⎥                 try message.backend_payload.set(
 78 ⎥                     .{ .user_error_message = "State is a required field." },
 79 ⎥                 );
 80 ⎥                 return;
 81 ⎥             }
 82 ⎥             if (contact.zip == null) {
 83 ⎥                 try message.backend_payload.set(
 84 ⎥                     .{ .user_error_message = "Zip is a required field." },
 85 ⎥                 );
 86 ⎥                 return;
 87 ⎥             }
 88 ⎥             // Store the record.
 89 ⎥             try self.store.contact_table.add(contact.name.?, contact.address.?, contact.city.?, contact.state.?, contact.zip.?);
 90 ⎥         } else {
 91 ⎥             return error.AddContactMessageMissingContact;
 92 ⎥         }
 93 ⎥     }
 94 ⎥ };
 95 ⎥ 
 96 ⎥ pub fn init(startup: _startup_.Backend) !*Messenger {
 97 ⎥     var messenger: *Messenger = try startup.allocator.create(Messenger);
 98 ⎥     messenger.allocator = startup.allocator;
 99 ⎥     messenger.send_channels = startup.send_channels;
100 ⎥     messenger.receive_channels = startup.receive_channels;
101 ⎥     messenger.triggers = startup.triggers;
102 ⎥     messenger.exit = startup.exit;
103 ⎥     messenger.store = startup.store;
104 ⎥ 
105 ⎥     // Subscribe to receive the AddContact message.
106 ⎥     var receive_behavior = try startup.receive_channels.AddContact.initBehavior();
107 ⎥     errdefer {
108 ⎥         messenger.deinit();
109 ⎥     }
110 ⎥     receive_behavior.implementor = messenger;
111 ⎥     receive_behavior.receiveFn = &Messenger.receiveAddContactFn;
112 ⎥     try startup.receive_channels.AddContact.subscribe(receive_behavior);
113 ⎥     errdefer {
114 ⎥         messenger.deinit();
115 ⎥     }
116 ⎥ 
117 ⎥     return messenger;
118 ⎥ }
119 ⎥ 
```

## The EditContact message and back-end messenger

### EditContact message

The EditContact message contains the user's edits to a contact record. The backend_payload only carries a user_error_message for when a user error occurs.

My only edits to the message file are for the frontend_payload.

* lines 21
* lines 31 - 36
* line 42
* lines 47 - 49
* lines 60 - 62

```zig
  1 ⎥ /// This file was generated by kickzig when you added the "EditContact" message.
  2 ⎥ /// This file will be removed by kickzig if you remove the "EditContact" message.
  3 ⎥ /// The "EditContact" message is:
  4 ⎥ /// * sent from the front-end to the back-end
  5 ⎥ /// * with the back-end possibly returning the message back to the front-end.
  6 ⎥ /// The front-end will:
  7 ⎥ /// 1. init this message.
  8 ⎥ /// 2. set the front-end payload.
  9 ⎥ /// 3. send the message to the back-end.
 10 ⎥ /// The back-end will:
 11 ⎥ /// 1. receive the message and do something with the data in the front-end payload.
 12 ⎥ /// 2. The back-end may also:
 13 ⎥ ///    i.   make a return copy.
 14 ⎥ ///    ii.  set the back-end payload.
 15 ⎥ ///    iii. send the return copy back to the front-end.
 16 ⎥ /// The front-end upon receiving the returned message:
 17 ⎥ ///    i.  will process the data in the back-end payload.
 18 ⎥ ///    ii. WILL NOT RETURN THE MESSAGE TO THE BACK-END.
 19 ⎥ const std = @import("std");
 20 ⎥ const Counter = @import("counter").Counter;
 21 ⎥ const Contact = @import("record").Edit;
 22 ⎥ 
 23 ⎥ // FrontendPayload is the "EditContact" message from the front-end to the back-end.
 24 ⎥ /// KICKZIG TODO: Add your own front-end payload fields and methods.
 25 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 26 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 27 ⎥ pub const FrontendPayload = struct {
 28 ⎥     allocator: std.mem.Allocator,
 29 ⎥     is_set: bool,
 30 ⎥ 
 31 ⎥     // The member contact is the contact the user has edited.
 32 ⎥     contact: ?*const Contact,
 33 ⎥ 
 34 ⎥     pub const Settings = struct {
 35 ⎥         contact: ?*const Contact = null,
 36 ⎥     };
 37 ⎥ 
 38 ⎥     fn init(allocator: std.mem.Allocator) !*FrontendPayload {
 39 ⎥         var self: *FrontendPayload = try allocator.create(FrontendPayload);
 40 ⎥         self.allocator = allocator;
 41 ⎥         self.is_set = false;
 42 ⎥         self.contact = null;
 43 ⎥         return self;
 44 ⎥     }
 45 ⎥ 
 46 ⎥     fn deinit(self: *FrontendPayload) void {
 47 ⎥         if (self.contact) |contact| {
 48 ⎥             @constCast(contact).deinit();
 49 ⎥         }
 50 ⎥         self.allocator.destroy(self);
 51 ⎥     }
 52 ⎥ 
 53 ⎥     // Returns an error if already set.
 54 ⎥     // Parameter values.contact is owned by FrontendPayload.
 55 ⎥     pub fn set(self: *FrontendPayload, values: Settings) !void {
 56 ⎥         if (self.is_set) {
 57 ⎥             return error.EditContactFrontendPayloadAlreadySet;
 58 ⎥         }
 59 ⎥         self.is_set = true;
 60 ⎥         if (values.contact) |contact| {
 61 ⎥             self.contact = contact;
 62 ⎥         }
 63 ⎥     }
 64 ⎥ };
 65 ⎥ 
 66 ⎥ // BackendPayload is the "EditContact" message from the back-end to the front-end.
 67 ⎥ /// KICKZIG TODO: Add your own back-end payload fields and methods.
 68 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 69 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 70 ⎥ pub const BackendPayload = struct {
 71 ⎥     allocator: std.mem.Allocator = undefined,
 72 ⎥     is_set: bool,
 73 ⎥ 
 74 ⎥     // The member user_error_message is presented as an example.
 75 ⎥     user_error_message: ?[]const u8,
 76 ⎥ 
 77 ⎥     pub const Settings = struct {
 78 ⎥         user_error_message: ?[]const u8 = null,
 79 ⎥     };
 80 ⎥ 
 81 ⎥     fn init(allocator: std.mem.Allocator) !*BackendPayload {
 82 ⎥         var self: *BackendPayload = try allocator.create(BackendPayload);
 83 ⎥         self.allocator = allocator;
 84 ⎥         self.user_error_message = null;
 85 ⎥         return self;
 86 ⎥     }
 87 ⎥ 
 88 ⎥     fn deinit(self: *BackendPayload) void {
 89 ⎥         if (self.user_error_message) |user_error_message| {
 90 ⎥             self.allocator.free(user_error_message);
 91 ⎥         }
 92 ⎥         self.allocator.destroy(self);
 93 ⎥     }
 94 ⎥ 
 95 ⎥     // Returns an error if already set.
 96 ⎥     pub fn set(self: *BackendPayload, values: Settings) !void {
 97 ⎥         if (self.is_set) {
 98 ⎥             return error.EditContactBackendPayloadAlreadySet;
 99 ⎥         }
100 ⎥         self.is_set = true;
101 ⎥         if (values.user_error_message) |user_error_message| {
102 ⎥             self.user_error_message = try self.allocator.alloc(u8, user_error_message.len);
103 ⎥             @memcpy(@constCast(self.user_error_message), user_error_message);
104 ⎥         }
105 ⎥     }
106 ⎥ };
107 ⎥ 
108 ⎥ /// This is the "EditContact" message.
109 ⎥ pub const Message = struct {
110 ⎥     allocator: std.mem.Allocator,
111 ⎥     count_pointers: *Counter,
112 ⎥     frontend_payload: *FrontendPayload,
113 ⎥     backend_payload: *BackendPayload,
114 ⎥ 
115 ⎥     // deinit does not deinit until self is the final pointer to Message.
116 ⎥     pub fn deinit(self: *Message) void {
117 ⎥         if (self.count_pointers.dec() > 0) {
118 ⎥             // There are more pointers.
119 ⎥             // See fn copy.
120 ⎥             return;
121 ⎥         }
122 ⎥         // This is the last existing pointer.
123 ⎥         self.allocator.destroy(self);
124 ⎥     }
125 ⎥ 
126 ⎥     /// KICKZIG TODO:
127 ⎥     /// copy pretends to create and return a copy of the message.
128 ⎥     /// The dispatcher sends a copy to each receiveFn.
129 ⎥     /// Each receiveFn owns the message copy and must deinit it.
130 ⎥     /// The back-end receiveFn must only send a copy to the front-end.
131 ⎥     /// Back-end Messenger Example:
132 ⎥     /// var return_copy = message.copy() catch |err| {
133 ⎥     ///     self.exit(@src(), err, "message.copy()");
134 ⎥     /// };
135 ⎥     /// // Set the back-end payload.
136 ⎥     /// return_copy.backend_payload.set(.{.name = record.name}) catch |err| {
137 ⎥     ///     self.exit(@src(), err, "return_copy.backend_payload.set(.{.name = record.name})");
138 ⎥     /// };
139 ⎥     /// // Send the message copy to the front-end.
140 ⎥     /// // The channel's send function owns the copy and will deinit it.
141 ⎥     /// self.send_channels.EditContact.send(message) catch |err| {
142 ⎥     ///     self.exit(@src(), err, "self.send_channels.EditContact.send(message)");
143 ⎥     /// };
144 ⎥     ///
145 ⎥     /// In this case copy does not return a copy of itself.
146 ⎥     /// In order to save memory space, it really only
147 ⎥     /// * increments the count of the number of pointers to this message.
148 ⎥     /// * returns self.
149 ⎥     /// See deinit().
150 ⎥     pub fn copy(self: *Message) !*Message {
151 ⎥         _ = self.count_pointers.inc();
152 ⎥         return self;
153 ⎥     }
154 ⎥ };
155 ⎥ 
156 ⎥ /// init creates an original message.
157 ⎥ pub fn init(allocator: std.mem.Allocator) !*Message {
158 ⎥     var self: *Message = try allocator.create(Message);
159 ⎥     self.frontend_payload = try FrontendPayload.init(allocator);
160 ⎥     errdefer {
161 ⎥         allocator.destroy(self);
162 ⎥     }
163 ⎥     self.backend_payload = try BackendPayload.init(allocator);
164 ⎥     errdefer {
165 ⎥         self.frontend_payload.deinit();
166 ⎥         allocator.destroy(self);
167 ⎥     }
168 ⎥     self.count_pointers = try Counter.init(allocator);
169 ⎥     errdefer {
170 ⎥         self.backend_payload.deinit();
171 ⎥         self.frontend_payload.deinit();
172 ⎥         allocator.destroy(self);
173 ⎥     }
174 ⎥     _ = self.count_pointers.inc();
175 ⎥     self.allocator = allocator;
176 ⎥     return self;
177 ⎥ }
178 ⎥ 
```

### EditContact back-end messenger

The EditContact back-end messenger updates the store with the user's edits to the record. Then the EditContact back-end messenger triggers the RebuildContactList messenger.

My only edits to the messenger file are

* line 14
* line 22
* lines 46 - 51
* lines 57 - 103
* line 114

```zig
  1 ⎥ /// This is the back-end's "EditContact" message handler.
  2 ⎥ /// This messenger can receive the "EditContact" message from the front-end
  3 ⎥ ///     and then if needed, send the "EditContact" message back to the front-end.
  4 ⎥ /// The "EditContact" message is at deps/message/src/EditContact.zig.
  5 ⎥ /// This file was generated by kickzig when you added the "EditContact" message.
  6 ⎥ /// This file will be removed by kickzig when you remove the "EditContact" message.
  7 ⎥ /// KICKZIG TODO: Customize fn receiveFn.
  8 ⎥ const std = @import("std");
  9 ⎥ 
 10 ⎥ const _channel_ = @import("channel");
 11 ⎥ const _message_ = @import("message");
 12 ⎥ const _startup_ = @import("startup");
 13 ⎥ const ExitFn = @import("various").ExitFn;
 14 ⎥ const Store = @import("store").Store;
 15 ⎥ 
 16 ⎥ pub const Messenger = struct {
 17 ⎥     allocator: std.mem.Allocator,
 18 ⎥     send_channels: *_channel_.BackendToFrontend,
 19 ⎥     receive_channels: *_channel_.FrontendToBackend,
 20 ⎥     triggers: *_channel_.Trigger,
 21 ⎥     exit: ExitFn,
 22 ⎥     store: *Store,
 23 ⎥ 
 24 ⎥     pub fn deinit(self: *Messenger) void {
 25 ⎥         self.allocator.destroy(self);
 26 ⎥     }
 27 ⎥ 
 28 ⎥     /// receiveEditContactFn receives the "EditContact" message from the front-end.
 29 ⎥     /// It implements _channel_.FrontendToBackend.EditContact.Behavior.receiveFn found in deps/channel/fronttoback/EditContact.zig.
 30 ⎥     /// The receiveEditContactFn owns the message it receives.
 31 ⎥     pub fn receiveEditContactFn(implementor: *anyopaque, message: *_message_.EditContact.Message) anyerror!void {
 32 ⎥         var self: *Messenger = @alignCast(@ptrCast(implementor));
 33 ⎥         defer message.deinit();
 34 ⎥ 
 35 ⎥         self.receiveJob(message) catch |err| {
 36 ⎥             // Fatal error.
 37 ⎥             self.exit(@src(), err, "self.receiveJob(message)");
 38 ⎥             return err;
 39 ⎥         };
 40 ⎥         // Send the send the reply to the front-end if required.
 41 ⎥         self.send_channels.EditContact.send(message) catch |err| {
 42 ⎥             // Fatal error.
 43 ⎥             self.exit(@src(), err, "self.send_channels.EditContact.send(message)");
 44 ⎥             return err;
 45 ⎥         };
 46 ⎥         if (message.backend_payload.user_error_message.?.len == 0) {
 47 ⎥             // There are no warnings for the user so the record was added.
 48 ⎥             // The stored data has changed with the added record.
 49 ⎥             // Start new lists.
 50 ⎥             try self.triggers.RebuildContactList.trigger();
 51 ⎥         }
 52 ⎥     }
 53 ⎥ 
 54 ⎥     /// receiveJob fullfills the front-end's request.
 55 ⎥     /// Returns nothing or an error.
 56 ⎥     fn receiveJob(self: *Messenger, message: *_message_.EditContact.Message) !void {
 57 ⎥         if (message.frontend_payload.contact) |contact| {
 58 ⎥             if (contact.id == 0) {
 59 ⎥                 try message.backend_payload.set(
 60 ⎥                     .{ .user_error_message = "ID is a required field." },
 61 ⎥                 );
 62 ⎥                 return;
 63 ⎥             }
 64 ⎥             if (contact.name == null) {
 65 ⎥                 try message.backend_payload.set(
 66 ⎥                     .{ .user_error_message = "Name is a required field." },
 67 ⎥                 );
 68 ⎥                 return;
 69 ⎥             }
 70 ⎥ 
 71 ⎥             if (contact.address == null) {
 72 ⎥                 try message.backend_payload.set(
 73 ⎥                     .{ .user_error_message = "Address is a required field." },
 74 ⎥                 );
 75 ⎥                 return;
 76 ⎥             }
 77 ⎥ 
 78 ⎥             if (contact.city == null) {
 79 ⎥                 try message.backend_payload.set(
 80 ⎥                     .{ .user_error_message = "City is a required field." },
 81 ⎥                 );
 82 ⎥                 return;
 83 ⎥             }
 84 ⎥ 
 85 ⎥             if (contact.state == null) {
 86 ⎥                 try message.backend_payload.set(
 87 ⎥                     .{ .user_error_message = "State is a required field." },
 88 ⎥                 );
 89 ⎥                 return;
 90 ⎥             }
 91 ⎥ 
 92 ⎥             if (contact.zip == null) {
 93 ⎥                 try message.backend_payload.set(
 94 ⎥                     .{ .user_error_message = "Zip is a required field." },
 95 ⎥                 );
 96 ⎥                 return;
 97 ⎥             }
 98 ⎥ 
 99 ⎥             // Store the record.
100 ⎥             try self.store.contact_table.update(contact.id, contact.name.?, contact.address.?, contact.city.?, contact.state.?, contact.zip.?);
101 ⎥         } else {
102 ⎥             return error.EditContactMessageMissingContact;
103 ⎥         }
104 ⎥     }
105 ⎥ };
106 ⎥ 
107 ⎥ pub fn init(startup: _startup_.Backend) !*Messenger {
108 ⎥     var messenger: *Messenger = try startup.allocator.create(Messenger);
109 ⎥     messenger.allocator = startup.allocator;
110 ⎥     messenger.send_channels = startup.send_channels;
111 ⎥     messenger.receive_channels = startup.receive_channels;
112 ⎥     messenger.triggers = startup.triggers;
113 ⎥     messenger.exit = startup.exit;
114 ⎥     messenger.store = startup.store;
115 ⎥ 
116 ⎥     // Subscribe to receive the EditContact message.
117 ⎥     var receive_behavior = try startup.receive_channels.EditContact.initBehavior();
118 ⎥     errdefer {
119 ⎥         messenger.deinit();
120 ⎥     }
121 ⎥     receive_behavior.implementor = messenger;
122 ⎥     receive_behavior.receiveFn = &Messenger.receiveEditContactFn;
123 ⎥     try startup.receive_channels.EditContact.subscribe(receive_behavior);
124 ⎥     errdefer {
125 ⎥         messenger.deinit();
126 ⎥     }
127 ⎥ 
128 ⎥     return messenger;
129 ⎥ }
130 ⎥ 
```

## The RemoveContact message and back-end messenger

### RemoveContact message

The RemoveContact message contains the id of a contact record that the user wants removed. That id is contained in the message's frontend_payload which is set by the front-end. The backend_payload only carries a user_error_message for when a user error occurs.

My only edits to the message file are for the frontend_payload.

* lines 21
* lines 31 - 36
* line 42
* lines 47 - 49
* lines 60 - 62

```zig
  1 ⎥ /// This file was generated by kickzig when you added the "RemoveContact" message.
  2 ⎥ /// This file will be removed by kickzig if you remove the "RemoveContact" message.
  3 ⎥ /// The "RemoveContact" message is:
  4 ⎥ /// * sent from the front-end to the back-end
  5 ⎥ /// * with the back-end possibly returning the message back to the front-end.
  6 ⎥ /// The front-end will:
  7 ⎥ /// 1. init this message.
  8 ⎥ /// 2. set the front-end payload.
  9 ⎥ /// 3. send the message to the back-end.
 10 ⎥ /// The back-end will:
 11 ⎥ /// 1. receive the message and do something with the data in the front-end payload.
 12 ⎥ /// 2. The back-end may also:
 13 ⎥ ///    i.   make a return copy.
 14 ⎥ ///    ii.  set the back-end payload.
 15 ⎥ ///    iii. send the return copy back to the front-end.
 16 ⎥ /// The front-end upon receiving the returned message:
 17 ⎥ ///    i.  will process the data in the back-end payload.
 18 ⎥ ///    ii. WILL NOT RETURN THE MESSAGE TO THE BACK-END.
 19 ⎥ const std = @import("std");
 20 ⎥ const Counter = @import("counter").Counter;
 21 ⎥ const Contact = @import("record").Remove;
 22 ⎥ 
 23 ⎥ // FrontendPayload is the "RemoveContact" message from the front-end to the back-end.
 24 ⎥ /// KICKZIG TODO: Add your own front-end payload fields and methods.
 25 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 26 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 27 ⎥ pub const FrontendPayload = struct {
 28 ⎥     allocator: std.mem.Allocator,
 29 ⎥     is_set: bool,
 30 ⎥ 
 31 ⎥     // The member id is presented as an example.
 32 ⎥     contact: ?*const Contact,
 33 ⎥ 
 34 ⎥     pub const Settings = struct {
 35 ⎥         contact: ?*const Contact = null,
 36 ⎥     };
 37 ⎥ 
 38 ⎥     fn init(allocator: std.mem.Allocator) !*FrontendPayload {
 39 ⎥         var self: *FrontendPayload = try allocator.create(FrontendPayload);
 40 ⎥         self.allocator = allocator;
 41 ⎥         self.is_set = false;
 42 ⎥         self.contact = null;
 43 ⎥         return self;
 44 ⎥     }
 45 ⎥ 
 46 ⎥     fn deinit(self: *FrontendPayload) void {
 47 ⎥         if (self.contact) |contact| {
 48 ⎥             @constCast(contact).deinit();
 49 ⎥         }
 50 ⎥         self.allocator.destroy(self);
 51 ⎥     }
 52 ⎥ 
 53 ⎥     // Returns an error if already set.
 54 ⎥     // Parameter values.contact is owned by FrontendPayload.
 55 ⎥     pub fn set(self: *FrontendPayload, values: Settings) !void {
 56 ⎥         if (self.is_set) {
 57 ⎥             return error.RemoveContactFrontendPayloadAlreadySet;
 58 ⎥         }
 59 ⎥         self.is_set = true;
 60 ⎥         if (values.contact) |contact| {
 61 ⎥             self.contact = contact;
 62 ⎥         }
 63 ⎥     }
 64 ⎥ };
 65 ⎥ 
 66 ⎥ // BackendPayload is the "RemoveContact" message from the back-end to the front-end.
 67 ⎥ /// KICKZIG TODO: Add your own back-end payload fields and methods.
 68 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 69 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 70 ⎥ pub const BackendPayload = struct {
 71 ⎥     allocator: std.mem.Allocator = undefined,
 72 ⎥     is_set: bool,
 73 ⎥ 
 74 ⎥     // The member user_error_message is presented as an example.
 75 ⎥     user_error_message: ?[]const u8,
 76 ⎥ 
 77 ⎥     pub const Settings = struct {
 78 ⎥         user_error_message: ?[]const u8 = null,
 79 ⎥     };
 80 ⎥ 
 81 ⎥     fn init(allocator: std.mem.Allocator) !*BackendPayload {
 82 ⎥         var self: *BackendPayload = try allocator.create(BackendPayload);
 83 ⎥         self.allocator = allocator;
 84 ⎥         self.user_error_message = null;
 85 ⎥         return self;
 86 ⎥     }
 87 ⎥ 
 88 ⎥     fn deinit(self: *BackendPayload) void {
 89 ⎥         if (self.user_error_message) |user_error_message| {
 90 ⎥             self.allocator.free(user_error_message);
 91 ⎥         }
 92 ⎥         self.allocator.destroy(self);
 93 ⎥     }
 94 ⎥ 
 95 ⎥     // Returns an error if already set.
 96 ⎥     pub fn set(self: *BackendPayload, values: Settings) !void {
 97 ⎥         if (self.is_set) {
 98 ⎥             return error.RemoveContactBackendPayloadAlreadySet;
 99 ⎥         }
100 ⎥         self.is_set = true;
101 ⎥         if (values.user_error_message) |user_error_message| {
102 ⎥             self.user_error_message = try self.allocator.alloc(u8, user_error_message.len);
103 ⎥             @memcpy(@constCast(self.user_error_message), user_error_message);
104 ⎥         }
105 ⎥     }
106 ⎥ };
107 ⎥ 
108 ⎥ /// This is the "RemoveContact" message.
109 ⎥ pub const Message = struct {
110 ⎥     allocator: std.mem.Allocator,
111 ⎥     count_pointers: *Counter,
112 ⎥     frontend_payload: *FrontendPayload,
113 ⎥     backend_payload: *BackendPayload,
114 ⎥ 
115 ⎥     // deinit does not deinit until self is the final pointer to Message.
116 ⎥     pub fn deinit(self: *Message) void {
117 ⎥         if (self.count_pointers.dec() > 0) {
118 ⎥             // There are more pointers.
119 ⎥             // See fn copy.
120 ⎥             return;
121 ⎥         }
122 ⎥         // This is the last existing pointer.
123 ⎥         self.allocator.destroy(self);
124 ⎥     }
125 ⎥ 
126 ⎥     /// KICKZIG TODO:
127 ⎥     /// copy pretends to create and return a copy of the message.
128 ⎥     /// The dispatcher sends a copy to each receiveFn.
129 ⎥     /// Each receiveFn owns the message copy and must deinit it.
130 ⎥     /// The back-end receiveFn must only send a copy to the front-end.
131 ⎥     /// Back-end Messenger Example:
132 ⎥     /// var return_copy = message.copy() catch |err| {
133 ⎥     ///     self.exit(@src(), err, "message.copy()");
134 ⎥     /// };
135 ⎥     /// // Set the back-end payload.
136 ⎥     /// return_copy.backend_payload.set(.{.name = record.name}) catch |err| {
137 ⎥     ///     self.exit(@src(), err, "return_copy.backend_payload.set(.{.name = record.name})");
138 ⎥     /// };
139 ⎥     /// // Send the message copy to the front-end.
140 ⎥     /// // The channel's send function owns the copy and will deinit it.
141 ⎥     /// self.send_channels.RemoveContact.send(message) catch |err| {
142 ⎥     ///     self.exit(@src(), err, "self.send_channels.RemoveContact.send(message)");
143 ⎥     /// };
144 ⎥     ///
145 ⎥     /// In this case copy does not return a copy of itself.
146 ⎥     /// In order to save memory space, it really only
147 ⎥     /// * increments the count of the number of pointers to this message.
148 ⎥     /// * returns self.
149 ⎥     /// See deinit().
150 ⎥     pub fn copy(self: *Message) !*Message {
151 ⎥         _ = self.count_pointers.inc();
152 ⎥         return self;
153 ⎥     }
154 ⎥ };
155 ⎥ 
156 ⎥ /// init creates an original message.
157 ⎥ pub fn init(allocator: std.mem.Allocator) !*Message {
158 ⎥     var self: *Message = try allocator.create(Message);
159 ⎥     self.frontend_payload = try FrontendPayload.init(allocator);
160 ⎥     errdefer {
161 ⎥         allocator.destroy(self);
162 ⎥     }
163 ⎥     self.backend_payload = try BackendPayload.init(allocator);
164 ⎥     errdefer {
165 ⎥         self.frontend_payload.deinit();
166 ⎥         allocator.destroy(self);
167 ⎥     }
168 ⎥     self.count_pointers = try Counter.init(allocator);
169 ⎥     errdefer {
170 ⎥         self.backend_payload.deinit();
171 ⎥         self.frontend_payload.deinit();
172 ⎥         allocator.destroy(self);
173 ⎥     }
174 ⎥     _ = self.count_pointers.inc();
175 ⎥     self.allocator = allocator;
176 ⎥     return self;
177 ⎥ }
178 ⎥ 
```

### RemoveContact back-end messenger

The RemoveContact back-end messenger removes the user selected contact record from the store.

My only edits to the messenger file are

* line 14
* line 22
* lines 55 - 59
* line 70

```zig
  1 ⎥ /// This is the back-end's "RemoveContact" message handler.
  2 ⎥ /// This messenger can receive the "RemoveContact" message from the front-end
  3 ⎥ ///     and then if needed, send the "RemoveContact" message back to the front-end.
  4 ⎥ /// The "RemoveContact" message is at deps/message/src/RemoveContact.zig.
  5 ⎥ /// This file was generated by kickzig when you added the "RemoveContact" message.
  6 ⎥ /// This file will be removed by kickzig when you remove the "RemoveContact" message.
  7 ⎥ /// KICKZIG TODO: Customize fn receiveFn.
  8 ⎥ const std = @import("std");
  9 ⎥ 
 10 ⎥ const _channel_ = @import("channel");
 11 ⎥ const _message_ = @import("message");
 12 ⎥ const _startup_ = @import("startup");
 13 ⎥ const ExitFn = @import("various").ExitFn;
 14 ⎥ const Store = @import("store").Store;
 15 ⎥ 
 16 ⎥ pub const Messenger = struct {
 17 ⎥     allocator: std.mem.Allocator,
 18 ⎥     send_channels: *_channel_.BackendToFrontend,
 19 ⎥     receive_channels: *_channel_.FrontendToBackend,
 20 ⎥     triggers: *_channel_.Trigger,
 21 ⎥     exit: ExitFn,
 22 ⎥     store: *Store,
 23 ⎥ 
 24 ⎥     pub fn deinit(self: *Messenger) void {
 25 ⎥         self.allocator.destroy(self);
 26 ⎥     }
 27 ⎥ 
 28 ⎥     /// receiveRemoveContactFn receives the "RemoveContact" message from the front-end.
 29 ⎥     /// It implements _channel_.FrontendToBackend.RemoveContact.Behavior.receiveFn found in deps/channel/fronttoback/RemoveContact.zig.
 30 ⎥     /// The receiveRemoveContactFn owns the message it receives.
 31 ⎥     pub fn receiveRemoveContactFn(implementor: *anyopaque, message: *_message_.RemoveContact.Message) anyerror!void {
 32 ⎥         var self: *Messenger = @alignCast(@ptrCast(implementor));
 33 ⎥         defer message.deinit();
 34 ⎥ 
 35 ⎥         self.receiveJob(message) catch |err| {
 36 ⎥             // Fatal error.
 37 ⎥             self.exit(@src(), err, "self.receiveJob(message)");
 38 ⎥             return err;
 39 ⎥         };
 40 ⎥         // Send the send the reply to the front-end if required.
 41 ⎥         self.send_channels.RemoveContact.send(message) catch |err| {
 42 ⎥             // Fatal error.
 43 ⎥             self.exit(@src(), err, "self.send_channels.RemoveContact.send(message)");
 44 ⎥             return err;
 45 ⎥         };
 46 ⎥         // The stored data has changed with the removed record.
 47 ⎥         // Start new lists.
 48 ⎥         try self.triggers.RebuildContactList.trigger();
 49 ⎥     }
 50 ⎥ 
 51 ⎥     /// receiveJob fullfills the front-end's request.
 52 ⎥     /// Returns nothing or an error.
 53 ⎥     /// KICKZIG TODO: Add the required functionality.
 54 ⎥     fn receiveJob(self: *Messenger, message: *_message_.RemoveContact.Message) !void {
 55 ⎥         if (message.frontend_payload.contact) |contact| {
 56 ⎥             return self.store.contact_table.remove(contact.id);
 57 ⎥         } else {
 58 ⎥             return error.RebuildContactListMessageMissingContact;
 59 ⎥         }
 60 ⎥     }
 61 ⎥ };
 62 ⎥ 
 63 ⎥ pub fn init(startup: _startup_.Backend) !*Messenger {
 64 ⎥     var messenger: *Messenger = try startup.allocator.create(Messenger);
 65 ⎥     messenger.allocator = startup.allocator;
 66 ⎥     messenger.send_channels = startup.send_channels;
 67 ⎥     messenger.receive_channels = startup.receive_channels;
 68 ⎥     messenger.triggers = startup.triggers;
 69 ⎥     messenger.exit = startup.exit;
 70 ⎥     messenger.store = startup.store;
 71 ⎥ 
 72 ⎥     // Subscribe to receive the RemoveContact message.
 73 ⎥     var receive_behavior = try startup.receive_channels.RemoveContact.initBehavior();
 74 ⎥     errdefer {
 75 ⎥         messenger.deinit();
 76 ⎥     }
 77 ⎥     receive_behavior.implementor = messenger;
 78 ⎥     receive_behavior.receiveFn = &Messenger.receiveRemoveContactFn;
 79 ⎥     try startup.receive_channels.RemoveContact.subscribe(receive_behavior);
 80 ⎥     errdefer {
 81 ⎥         messenger.deinit();
 82 ⎥     }
 83 ⎥ 
 84 ⎥     return messenger;
 85 ⎥ }
 86 ⎥ 
```

## Next

[[Kickstarting The Backend|Kickstarting-The-Backend]]
