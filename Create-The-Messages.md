## Messages are part of the kickzig framework

### kickzig offers 3 types of messages

1. The **Back to Front** message
   * the back-end sends information to the front-end.
   * the front-end processes the data
   * the front-end does not reply because the back-end messenger does not receive, it only sends.
   * The back-end messenger only sends when triggered from some other back-end module.
1. The **Front to Back to Front** message
   * the front-end sends a request to the back-end.
   * the back-end tries to fullfill the request.
   * the back-end sends the requested information or some other expected response or no response at all if there were no errors.
1. The **Back to Front & Front to Back to Front** message is a combination of the above 2 messages.

When kickzig adds a message it also

* adds a back-end messenger to handle the message.
* modifies the back-end messenger package's api.

You can develop the back-end anyway you want around the framework.

I like to initialize tools for the back-end like the **data store** in standalone-sdl.zig and then pass them to the back-end init function, which passes the tools on to the back-end messengers init functions. But that's just me.

So here is what I did.

## Step 1: Add all the messages

### The RebuildContactList message

The RebuildContactList message contains a list of all of the contacts.
The RebuildContactList back-end messenger gets the list of contacts from the store and sends the list to the front-end. The back-end messenger only sends the list when triggered from some other back-end module.

```shell
＄ kickzig message add-bf RebuildContactList
Added the RebuildContactList message at /home/nil/zig/crud/src/@This/deps/message/RebuildContactList.zig:1:1:
Added the back-end RebuildContactList messenger at /home/nil/zig/crud/src/@This/backend/messenger/RebuildContactList.zig:1:1:
```

### The AddContact message

The AddContact message contains the new user created contact record.
The AddContact back-end messenger adds the new user created contact record to the store. Then the AddContact back-end messenger triggers the RebuildContactList messenger.

```shell
＄ kickzig message add-fbf AddContact
Added the AddContact message at /home/nil/zig/crud/src/@This/deps/message/AddContact.zig:1:1:
Added the back-end AddContact messenger at /home/nil/zig/crud/src/@This/backend/messenger/AddContact.zig:1:1:
```

### The EditContact message

The EditContact message contains the user's edits to a contact record.
The EditContact back-end messenger updates the store with the user's edits to the record. Then the EditContact back-end messenger triggers the RebuildContactList messenger.

```shell
＄ kickzig message add-fbf EditContact
Added the EditContact message at /home/nil/zig/crud/src/@This/deps/message/EditContact.zig:1:1:
Added the back-end EditContact messenger at /home/nil/zig/crud/src/@This/backend/messenger/EditContact.zig:1:1:
```

### The RemoveContact message

The RemoveContact message contains the id of a contact record that the user wants removed.
The RemoveContact back-end messenger removes the user selected contact record from the store. Then the RemoveContact back-end messenger triggers the RebuildContactList messenger.

```shell
＄ kickzig message add-fbf RemoveContact
Added the RemoveContact message at /home/nil/zig/crud/src/@This/deps/message/RemoveContact.zig:1:1:
Added the back-end RemoveContact messenger at /home/nil/zig/crud/src/@This/backend/messenger/RemoveContact.zig:1:1:
```

## Step 2: Define the message payloads

### The RebuildContactList message and back-end handler

#### RebuildContactList Message

The RebuildContactList message contains a list of all of the contacts.

```zig
  1 ⎥ /// This file was generated by kickzig when you added the "RebuildContactList" message.
  2 ⎥ /// This file will be removed by kickzig if you remove the "RebuildContactList" message.
  3 ⎥ /// The "RebuildContactList" message is:
  4 ⎥ /// * sent from the back-end to the front-end only.
  5 ⎥ /// The back-end will:
  6 ⎥ /// 1. init this message.
  7 ⎥ /// 2. set the back-end payload.
  8 ⎥ /// 3. send the message to the front-end.
  9 ⎥ /// The front-end:
 10 ⎥ /// 1. will receive the message and process the data in the back-end payload.
 11 ⎥ /// 2. WILL NOT RETURN THE MESSAGE TO THE BACK-END.
 12 ⎥ const std = @import("std");
 13 ⎥ const Counter = @import("counter").Counter;
 14 ⎥ const Contact = @import("record").List;
 15 ⎥ 
 16 ⎥ // BackendPayload is the "RebuildContactList" message from the back-end to the front-end.
 17 ⎥ /// KICKZIG TODO: Add your own back-end payload fields and methods.
 18 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 19 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 20 ⎥ pub const BackendPayload = struct {
 21 ⎥     allocator: std.mem.Allocator = undefined,
 22 ⎥     is_set: bool,
 23 ⎥ 
 24 ⎥     // The member foofoo is presented as an example.
 25 ⎥     contacts: ?[]const *const Contact,
 26 ⎥ 
 27 ⎥     pub const Settings = struct {
 28 ⎥         contacts: ?[]const *const Contact,
 29 ⎥     };
 30 ⎥ 
 31 ⎥     fn init(allocator: std.mem.Allocator) !*BackendPayload {
 32 ⎥         var self: *BackendPayload = try allocator.create(BackendPayload);
 33 ⎥         self.allocator = allocator;
 34 ⎥         self.contacts = null;
 35 ⎥         return self;
 36 ⎥     }
 37 ⎥ 
 38 ⎥     fn deinit(self: *BackendPayload) void {
 39 ⎥         self.allocator.destroy(self);
 40 ⎥     }
 41 ⎥ 
 42 ⎥     // Returns an error if already set.
 43 ⎥     pub fn set(self: *BackendPayload, values: Settings) !void {
 44 ⎥         if (self.is_set) {
 45 ⎥             return error.RebuildContactListBackendPayloadAlreadySet;
 46 ⎥         }
 47 ⎥         self.is_set = true;
 48 ⎥         if (values.contacts) |contacts| {
 49 ⎥             self.contacts = contacts;
 50 ⎥         }
 51 ⎥     }
 52 ⎥ };
 53 ⎥ 
 54 ⎥ /// This is the "RebuildContactList" message.
 55 ⎥ pub const Message = struct {
 56 ⎥     allocator: std.mem.Allocator,
 57 ⎥     count_pointers: *Counter,
 58 ⎥     backend_payload: *BackendPayload,
 59 ⎥ 
 60 ⎥     // deinit does not deinit until self is the final pointer to Message.
 61 ⎥     pub fn deinit(self: *Message) void {
 62 ⎥         std.log.debug(" == Init msg.deinit()", .{});
 63 ⎥         if (self.count_pointers.dec() > 0) {
 64 ⎥             // There are more pointers.
 65 ⎥             // See fn copy.
 66 ⎥             return;
 67 ⎥         }
 68 ⎥         // This is the last existing pointer.
 69 ⎥         self.allocator.destroy(self);
 70 ⎥     }
 71 ⎥ 
 72 ⎥     /// KICKZIG TODO:
 73 ⎥     /// copy pretends to create and return a copy of the message.
 74 ⎥     /// The dispatcher sends a copy to each receiveFn.
 75 ⎥     /// Each receiveFn owns the message copy and must deinit it.
 76 ⎥     ///
 77 ⎥     /// In this case copy does not return a copy of itself.
 78 ⎥     /// In order to save memory space, it really only
 79 ⎥     /// * increments the count of the number of pointers to this message.
 80 ⎥     /// * returns self.
 81 ⎥     /// See deinit().
 82 ⎥     pub fn copy(self: *Message) !*Message {
 83 ⎥         _ = self.count_pointers.inc();
 84 ⎥         return self;
 85 ⎥     }
 86 ⎥ };
 87 ⎥ 
 88 ⎥ /// init creates an original message.
 89 ⎥ pub fn init(allocator: std.mem.Allocator) !*Message {
 90 ⎥     var self: *Message = try allocator.create(Message);
 91 ⎥     self.count_pointers = try Counter.init(allocator);
 92 ⎥     errdefer {
 93 ⎥         allocator.destroy(self);
 94 ⎥     }
 95 ⎥     self.backend_payload = try BackendPayload.init(allocator);
 96 ⎥     errdefer {
 97 ⎥         allocator.destroy(self);
 98 ⎥         self.count_pointers.deinit();
 99 ⎥     }
100 ⎥     _ = self.count_pointers.inc();
101 ⎥     self.allocator = allocator;
102 ⎥     return self;
103 ⎥ }
104 ⎥ 
```

#### RebuildContactList back-end messenger

The RebuildContactList back-end messenger gets the list of contacts from the store and sends the list to the front-end. It never does it on its own. It only sends the list when triggered from some other back-end module.

* backend/api.zig fn kickstart,
* by the AddContact back-end message handler,
* by the EditContact back-end message handler,
* by the RemoveContact back-end message handler.

```zig
  1 ⎥ /// This is the back-end's "RebuildContactList" message handler.
  2 ⎥ /// This messenger must be triggered to send a default "RebuildContactList" message to the front-end.
  3 ⎥ /// The "RebuildContactList" message is at deps/message/src/RebuildContactList.zig.
  4 ⎥ /// This file was generated by kickzig when you added the "RebuildContactList" message.
  5 ⎥ /// This file will be removed by kickzig when you remove the "RebuildContactList" message.
  6 ⎥ const std = @import("std");
  7 ⎥ const Store = @import("store").Store;
  8 ⎥ const Contact = @import("record").List;
  9 ⎥ 
 10 ⎥ const _channel_ = @import("channel");
 11 ⎥ const _message_ = @import("message");
 12 ⎥ const _startup_ = @import("startup");
 13 ⎥ 
 14 ⎥ pub const Messenger = struct {
 15 ⎥     allocator: std.mem.Allocator,
 16 ⎥     send_channels: *_channel_.BackendToFrontend,
 17 ⎥     receive_channels: *_channel_.FrontendToBackend,
 18 ⎥     exit: *const fn (user_message: []const u8) void,
 19 ⎥     store: *Store,
 20 ⎥ 
 21 ⎥     pub fn deinit(self: *Messenger) void {
 22 ⎥         self.allocator.destroy(self);
 23 ⎥     }
 24 ⎥ 
 25 ⎥     /// triggerRebuildContactListFn builds and sends the "RebuildContactList" message to the front-end.
 26 ⎥     /// It implements _channel_.FrontendToBackend.RebuildContactList.Behavior.triggerFn found in deps/channel/frontend/bf/RebuildContactList.zig.
 27 ⎥     /// The front-end must not send a response back with this message.
 28 ⎥     /// This messenger is not able to receive a RebuildContactList message.
 29 ⎥     pub fn triggerRebuildContactListFn(implementor: *anyopaque) ?anyerror {
 30 ⎥         var self: *Messenger = @alignCast(@ptrCast(implementor));
 31 ⎥ 
 32 ⎥         var message: *_message_.RebuildContactList.Message = self.triggerJob() catch |err| {
 33 ⎥             // Fatal error.
 34 ⎥             self.exit(@errorName(err));
 35 ⎥             return err;
 36 ⎥         };
 37 ⎥         // Send the message back to the front-end.
 38 ⎥         // The sender owns the message so never deinit the message.
 39 ⎥         self.send_channels.RebuildContactList.send(message) catch |err| {
 40 ⎥             // Fatal error.
 41 ⎥             self.exit(@errorName(err));
 42 ⎥             return err;
 43 ⎥         };
 44 ⎥         // No errors so return null;
 45 ⎥         return null;
 46 ⎥     }
 47 ⎥ 
 48 ⎥     /// triggerJob creates message to send to the front-end.
 49 ⎥     /// It gets an slice of all of the contacts and puts it in the message.
 50 ⎥     /// Returns the processed message or an error.
 51 ⎥     fn triggerJob(self: *Messenger) !*_message_.RebuildContactList.Message {
 52 ⎥         var message: *_message_.RebuildContactList.Message = try _message_.RebuildContactList.init(self.allocator);
 53 ⎥         var contacts: ?[]const *const Contact = try self.store.contact_table.getAll();
 54 ⎥         errdefer {
 55 ⎥             message.deinit();
 56 ⎥         }
 57 ⎥         try message.backend_payload.set(.{ .contacts = contacts });
 58 ⎥         return message;
 59 ⎥     }
 60 ⎥ };
 61 ⎥ 
 62 ⎥ pub fn init(startup: _startup_.Backend) !*Messenger {
 63 ⎥     var messenger: *Messenger = try startup.allocator.create(Messenger);
 64 ⎥     messenger.allocator = startup.allocator;
 65 ⎥     messenger.send_channels = startup.send_channels;
 66 ⎥     messenger.receive_channels = startup.receive_channels;
 67 ⎥     messenger.exit = startup.exit;
 68 ⎥     messenger.store = startup.store;
 69 ⎥ 
 70 ⎥     var trigger_behavior = try startup.triggers.RebuildContactList.initBehavior();
 71 ⎥     errdefer {
 72 ⎥         messenger.deinit();
 73 ⎥     }
 74 ⎥     trigger_behavior.implementor = messenger;
 75 ⎥     trigger_behavior.triggerFn = &Messenger.triggerRebuildContactListFn;
 76 ⎥     try startup.triggers.RebuildContactList.subscribe(trigger_behavior);
 77 ⎥     errdefer {
 78 ⎥         messenger.deinit();
 79 ⎥     }
 80 ⎥     return messenger;
 81 ⎥ }
 82 ⎥ 
```

### The AddContact message and back-end handler

#### AddContact Message

The AddContact message contains the new user created contact record.

```zig
  1 ⎥ /// This file was generated by kickzig when you added the "AddContact" message.
  2 ⎥ /// This file will be removed by kickzig if you remove the "AddContact" message.
  3 ⎥ /// The "AddContact" message is:
  4 ⎥ /// * sent from the front-end to the back-end
  5 ⎥ /// * with the back-end possibly returning the message back to the front-end.
  6 ⎥ /// The front-end will:
  7 ⎥ /// 1. init this message.
  8 ⎥ /// 2. set the front-end payload.
  9 ⎥ /// 3. send the message to the back-end.
 10 ⎥ /// The back-end will:
 11 ⎥ /// 1. receive the message and do something with the data in the front-end payload.
 12 ⎥ /// 2. The back-end may also:
 13 ⎥ ///    i.   make a return copy.
 14 ⎥ ///    ii.  set the back-end payload.
 15 ⎥ ///    iii. send the return copy back to the front-end.
 16 ⎥ /// The front-end upon receiving the returned message:
 17 ⎥ ///    i.  will process the data in the back-end payload.
 18 ⎥ ///    ii. WILL NOT RETURN THE MESSAGE TO THE BACK-END.
 19 ⎥ const std = @import("std");
 20 ⎥ const Counter = @import("counter").Counter;
 21 ⎥ const Contact = @import("record").Add;
 22 ⎥ 
 23 ⎥ // FrontendPayload is the "AddContact" message from the front-end to the back-end.
 24 ⎥ /// KICKZIG TODO: Add your own front-end payload fields and methods.
 25 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 26 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 27 ⎥ pub const FrontendPayload = struct {
 28 ⎥     allocator: std.mem.Allocator,
 29 ⎥     is_set: bool,
 30 ⎥ 
 31 ⎥     // The member contact is the contact the user has added.
 32 ⎥     contact: ?*Contact,
 33 ⎥ 
 34 ⎥     pub const Settings = struct {
 35 ⎥         contact: ?*Contact,
 36 ⎥     };
 37 ⎥ 
 38 ⎥     fn init(allocator: std.mem.Allocator) !*FrontendPayload {
 39 ⎥         var self: *FrontendPayload = try allocator.create(FrontendPayload);
 40 ⎥         self.allocator = allocator;
 41 ⎥         self.is_set = false;
 42 ⎥         self.contact = null;
 43 ⎥         return self;
 44 ⎥     }
 45 ⎥ 
 46 ⎥     fn deinit(self: *FrontendPayload) void {
 47 ⎥         self.allocator.destroy(self);
 48 ⎥     }
 49 ⎥ 
 50 ⎥     // Returns an error if already set.
 51 ⎥     pub fn set(self: *FrontendPayload, values: Settings) !void {
 52 ⎥         if (self.is_set) {
 53 ⎥             return error.AddContactFrontendPayloadAlreadySet;
 54 ⎥         }
 55 ⎥         self.is_set = true;
 56 ⎥         if (values.contact) |contact| {
 57 ⎥             self.contact = contact;
 58 ⎥         }
 59 ⎥     }
 60 ⎥ };
 61 ⎥ 
 62 ⎥ // BackendPayload is the "AddContact" message from the back-end to the front-end.
 63 ⎥ /// KICKZIG TODO: Add your own back-end payload fields and methods.
 64 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 65 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 66 ⎥ pub const BackendPayload = struct {
 67 ⎥     allocator: std.mem.Allocator = undefined,
 68 ⎥     is_set: bool,
 69 ⎥ 
 70 ⎥     // The member user_error_message is presented as an example.
 71 ⎥     user_error_message: ?[]const u8,
 72 ⎥ 
 73 ⎥     pub const Settings = struct {
 74 ⎥         user_error_message: ?[]const u8,
 75 ⎥     };
 76 ⎥ 
 77 ⎥     fn init(allocator: std.mem.Allocator) !*BackendPayload {
 78 ⎥         var self: *BackendPayload = try allocator.create(BackendPayload);
 79 ⎥         self.allocator = allocator;
 80 ⎥         self.user_error_message = null;
 81 ⎥         return self;
 82 ⎥     }
 83 ⎥ 
 84 ⎥     fn deinit(self: *BackendPayload) void {
 85 ⎥         if (self.user_error_message) |user_error_message| {
 86 ⎥             self.allocator.free(user_error_message);
 87 ⎥         }
 88 ⎥         self.allocator.destroy(self);
 89 ⎥     }
 90 ⎥ 
 91 ⎥     // Returns an error if already set.
 92 ⎥     pub fn set(self: *BackendPayload, values: Settings) !void {
 93 ⎥         if (self.is_set) {
 94 ⎥             return error.AddContactBackendPayloadAlreadySet;
 95 ⎥         }
 96 ⎥         self.is_set = true;
 97 ⎥         if (values.user_error_message) |user_error_message| {
 98 ⎥             self.user_error_message = try self.allocator.alloc(u8, user_error_message.len);
 99 ⎥             @memcpy(@constCast(self.user_error_message), user_error_message);
100 ⎥         }
101 ⎥     }
102 ⎥ };
103 ⎥ 
104 ⎥ /// This is the "AddContact" message.
105 ⎥ pub const Message = struct {
106 ⎥     allocator: std.mem.Allocator,
107 ⎥     count_pointers: *Counter,
108 ⎥     frontend_payload: *FrontendPayload,
109 ⎥     backend_payload: *BackendPayload,
110 ⎥ 
111 ⎥     // deinit does not deinit until self is the final pointer to Message.
112 ⎥     pub fn deinit(self: *Message) void {
113 ⎥         std.log.debug(" == Init msg.deinit()", .{});
114 ⎥         if (self.count_pointers.dec() > 0) {
115 ⎥             // There are more pointers.
116 ⎥             // See fn copy.
117 ⎥             return;
118 ⎥         }
119 ⎥         // This is the last existing pointer.
120 ⎥         self.allocator.destroy(self);
121 ⎥     }
122 ⎥ 
123 ⎥     /// KICKZIG TODO:
124 ⎥     /// copy pretends to create and return a copy of the message.
125 ⎥     /// The dispatcher sends a copy to each receiveFn.
126 ⎥     /// Each receiveFn owns the message copy and must deinit it.
127 ⎥     /// The back-end receiveFn must only send a copy to the front-end.
128 ⎥     /// Back-end Messenger Example:
129 ⎥     /// var return_copy = message.copy() catch |err| {
130 ⎥     ///     self.exit(@errorName(err));
131 ⎥     /// };
132 ⎥     /// // Set the back-end payload.
133 ⎥     /// return_copy.backend_payload.set(.{.name = record.name}) catch |err| {
134 ⎥     ///     self.exit(@errorName(err));
135 ⎥     /// };
136 ⎥     /// // Send the message copy to the front-end.
137 ⎥     /// // The channel's send function owns the copy and will deinit it.
138 ⎥     /// self.send_channels.AddContact.send(message) catch |err| {
139 ⎥     ///     self.exit(@errorName(err));
140 ⎥     /// };
141 ⎥     ///
142 ⎥     /// In this case copy does not return a copy of itself.
143 ⎥     /// In order to save memory space, it really only
144 ⎥     /// * increments the count of the number of pointers to this message.
145 ⎥     /// * returns self.
146 ⎥     /// See deinit().
147 ⎥     pub fn copy(self: *Message) !*Message {
148 ⎥         _ = self.count_pointers.inc();
149 ⎥         return self;
150 ⎥     }
151 ⎥ };
152 ⎥ 
153 ⎥ /// init creates an original message.
154 ⎥ pub fn init(allocator: std.mem.Allocator) !*Message {
155 ⎥     var self: *Message = try allocator.create(Message);
156 ⎥     self.frontend_payload = try FrontendPayload.init(allocator);
157 ⎥     errdefer {
158 ⎥         allocator.destroy(self);
159 ⎥     }
160 ⎥     self.backend_payload = try BackendPayload.init(allocator);
161 ⎥     errdefer {
162 ⎥         self.frontend_payload.deinit();
163 ⎥         allocator.destroy(self);
164 ⎥     }
165 ⎥     self.count_pointers = try Counter.init(allocator);
166 ⎥     errdefer {
167 ⎥         self.backend_payload.deinit();
168 ⎥         self.frontend_payload.deinit();
169 ⎥         allocator.destroy(self);
170 ⎥     }
171 ⎥     _ = self.count_pointers.inc();
172 ⎥     self.allocator = allocator;
173 ⎥     return self;
174 ⎥ }
175 ⎥ 
```

#### AddContact back-end messenger

The AddContact back-end messenger adds the new user created contact record to the store. Then the AddContact back-end messenger triggers the RebuildContactList messenger.

```zig
  1 ⎥ /// This is the back-end's "AddContact" message handler.
  2 ⎥ /// This messenger can receive the "AddContact" message from the front-end
  3 ⎥ ///     and then if needed, send the "AddContact" message back to the front-end.
  4 ⎥ /// The "AddContact" message is at deps/message/src/AddContact.zig.
  5 ⎥ /// This file was generated by kickzig when you added the "AddContact" message.
  6 ⎥ /// This file will be removed by kickzig when you remove the "AddContact" message.
  7 ⎥ /// KICKZIG TODO: Customize fn receiveFn.
  8 ⎥ const std = @import("std");
  9 ⎥ 
 10 ⎥ const _channel_ = @import("channel");
 11 ⎥ const _message_ = @import("message");
 12 ⎥ const _startup_ = @import("startup");
 13 ⎥ const Store = @import("store").Store;
 14 ⎥ 
 15 ⎥ pub const Messenger = struct {
 16 ⎥     allocator: std.mem.Allocator,
 17 ⎥     send_channels: *_channel_.BackendToFrontend,
 18 ⎥     receive_channels: *_channel_.FrontendToBackend,
 19 ⎥     exit: *const fn (user_message: []const u8) void,
 20 ⎥     store: *Store,
 21 ⎥ 
 22 ⎥     pub fn deinit(self: *Messenger) void {
 23 ⎥         self.allocator.destroy(self);
 24 ⎥     }
 25 ⎥ 
 26 ⎥     /// receiveAddContactFn receives the "AddContact" message from the front-end.
 27 ⎥     /// It implements _channel_.FrontendToBackend.AddContact.Behavior.receiveFn found in deps/channel/fronttoback/AddContact.zig.
 28 ⎥     /// The receiveAddContactFn owns the message it receives.
 29 ⎥     pub fn receiveAddContactFn(implementor: *anyopaque, message: *_message_.AddContact.Message) ?anyerror {
 30 ⎥         var self: *Messenger = @alignCast(@ptrCast(implementor));
 31 ⎥         defer message.deinit();
 32 ⎥ 
 33 ⎥         self.receiveJob(message) catch |err| {
 34 ⎥             // Fatal error.
 35 ⎥             self.exit(@errorName(err));
 36 ⎥             return err;
 37 ⎥         };
 38 ⎥ 
 39 ⎥         // Send the send the reply to the front-end if required.
 40 ⎥         self.send_channels.AddContact.send(message) catch |err| {
 41 ⎥             // Fatal error.
 42 ⎥             self.exit(@errorName(err));
 43 ⎥             return err;
 44 ⎥         };
 45 ⎥ 
 46 ⎥         // No errors so return null;
 47 ⎥         return null;
 48 ⎥     }
 49 ⎥ 
 50 ⎥     /// receiveJob fullfills the front-end's request.
 51 ⎥     /// If there is missing record information set the user_error_message and returns.
 52 ⎥     /// else adds the record in the store.
 53 ⎥     fn receiveJob(self: *Messenger, message: *_message_.AddContact.Message) !void {
 54 ⎥         if (message.frontend_payload.contact) |contact| {
 55 ⎥             if (contact.name == null) {
 56 ⎥                 try message.backend_payload.set(
 57 ⎥                     .{ .user_error_message = "Name is a required field." },
 58 ⎥                 );
 59 ⎥                 return;
 60 ⎥             }
 61 ⎥             if (contact.address == null) {
 62 ⎥                 try message.backend_payload.set(
 63 ⎥                     .{ .user_error_message = "Address is a required field." },
 64 ⎥                 );
 65 ⎥                 return;
 66 ⎥             }
 67 ⎥             if (contact.city == null) {
 68 ⎥                 try message.backend_payload.set(
 69 ⎥                     .{ .user_error_message = "City is a required field." },
 70 ⎥                 );
 71 ⎥                 return;
 72 ⎥             }
 73 ⎥             if (contact.state == null) {
 74 ⎥                 try message.backend_payload.set(
 75 ⎥                     .{ .user_error_message = "State is a required field." },
 76 ⎥                 );
 77 ⎥                 return;
 78 ⎥             }
 79 ⎥             if (contact.zip == null) {
 80 ⎥                 try message.backend_payload.set(
 81 ⎥                     .{ .user_error_message = "Zip is a required field." },
 82 ⎥                 );
 83 ⎥                 return;
 84 ⎥             }
 85 ⎥             // Store the record.
 86 ⎥             try self.store.contact_table.add(contact.name.?, contact.address.?, contact.city.?, contact.state.?, contact.zip.?);
 87 ⎥         } else {
 88 ⎥             return error.AddContactMessageMissingContact;
 89 ⎥         }
 90 ⎥     }
 91 ⎥ };
 92 ⎥ 
 93 ⎥ pub fn init(startup: _startup_.Backend) !*Messenger {
 94 ⎥     var messenger: *Messenger = try startup.allocator.create(Messenger);
 95 ⎥     messenger.allocator = startup.allocator;
 96 ⎥     messenger.send_channels = startup.send_channels;
 97 ⎥     messenger.receive_channels = startup.receive_channels;
 98 ⎥     var receive_behavior = try startup.receive_channels.AddContact.initBehavior();
 99 ⎥     errdefer {
100 ⎥         messenger.deinit();
101 ⎥     }
102 ⎥     receive_behavior.implementor = messenger;
103 ⎥     receive_behavior.receiveFn = &Messenger.receiveAddContactFn;
104 ⎥     try startup.receive_channels.AddContact.subscribe(receive_behavior);
105 ⎥     errdefer {
106 ⎥         messenger.deinit();
107 ⎥     }
108 ⎥     messenger.exit = startup.exit;
109 ⎥     messenger.store = startup.store;
110 ⎥     return messenger;
111 ⎥ }
112 ⎥ 
```

### The EditContact message and back-end messenger

#### EditContact message

The EditContact message contains the user's edits to a contact record.

```zig
  1 ⎥ /// This file was generated by kickzig when you added the "EditContact" message.
  2 ⎥ /// This file will be removed by kickzig if you remove the "EditContact" message.
  3 ⎥ /// The "EditContact" message is:
  4 ⎥ /// * sent from the front-end to the back-end
  5 ⎥ /// * with the back-end possibly returning the message back to the front-end.
  6 ⎥ /// The front-end will:
  7 ⎥ /// 1. init this message.
  8 ⎥ /// 2. set the front-end payload.
  9 ⎥ /// 3. send the message to the back-end.
 10 ⎥ /// The back-end will:
 11 ⎥ /// 1. receive the message and do something with the data in the front-end payload.
 12 ⎥ /// 2. The back-end may also:
 13 ⎥ ///    i.   make a return copy.
 14 ⎥ ///    ii.  set the back-end payload.
 15 ⎥ ///    iii. send the return copy back to the front-end.
 16 ⎥ /// The front-end upon receiving the returned message:
 17 ⎥ ///    i.  will process the data in the back-end payload.
 18 ⎥ ///    ii. WILL NOT RETURN THE MESSAGE TO THE BACK-END.
 19 ⎥ const std = @import("std");
 20 ⎥ const Counter = @import("counter").Counter;
 21 ⎥ const Contact = @import("record").Edit;
 22 ⎥ 
 23 ⎥ // FrontendPayload is the "EditContact" message from the front-end to the back-end.
 24 ⎥ /// KICKZIG TODO: Add your own front-end payload fields and methods.
 25 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 26 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 27 ⎥ pub const FrontendPayload = struct {
 28 ⎥     allocator: std.mem.Allocator,
 29 ⎥     is_set: bool,
 30 ⎥ 
 31 ⎥     // The member contact is the contact the user has edited.
 32 ⎥     contact: ?*Contact,
 33 ⎥ 
 34 ⎥     pub const Settings = struct {
 35 ⎥         contact: ?*Contact,
 36 ⎥     };
 37 ⎥ 
 38 ⎥     fn init(allocator: std.mem.Allocator) !*FrontendPayload {
 39 ⎥         var self: *FrontendPayload = try allocator.create(FrontendPayload);
 40 ⎥         self.allocator = allocator;
 41 ⎥         self.is_set = false;
 42 ⎥         self.contact = null;
 43 ⎥         return self;
 44 ⎥     }
 45 ⎥ 
 46 ⎥     fn deinit(self: *FrontendPayload) void {
 47 ⎥         self.allocator.destroy(self);
 48 ⎥     }
 49 ⎥ 
 50 ⎥     // Returns an error if already set.
 51 ⎥     pub fn set(self: *FrontendPayload, values: Settings) !void {
 52 ⎥         if (self.is_set) {
 53 ⎥             return error.EditContactFrontendPayloadAlreadySet;
 54 ⎥         }
 55 ⎥         self.is_set = true;
 56 ⎥         if (values.contact) |contact| {
 57 ⎥             self.contact = contact;
 58 ⎥         }
 59 ⎥     }
 60 ⎥ };
 61 ⎥ 
 62 ⎥ // BackendPayload is the "EditContact" message from the back-end to the front-end.
 63 ⎥ /// KICKZIG TODO: Add your own back-end payload fields and methods.
 64 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 65 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 66 ⎥ pub const BackendPayload = struct {
 67 ⎥     allocator: std.mem.Allocator = undefined,
 68 ⎥     is_set: bool,
 69 ⎥ 
 70 ⎥     // The member user_error_message is presented as an example.
 71 ⎥     user_error_message: ?[]const u8,
 72 ⎥ 
 73 ⎥     pub const Settings = struct {
 74 ⎥         user_error_message: ?[]const u8,
 75 ⎥     };
 76 ⎥ 
 77 ⎥     fn init(allocator: std.mem.Allocator) !*BackendPayload {
 78 ⎥         var self: *BackendPayload = try allocator.create(BackendPayload);
 79 ⎥         self.allocator = allocator;
 80 ⎥         self.user_error_message = null;
 81 ⎥         return self;
 82 ⎥     }
 83 ⎥ 
 84 ⎥     fn deinit(self: *BackendPayload) void {
 85 ⎥         if (self.user_error_message) |user_error_message| {
 86 ⎥             self.allocator.free(user_error_message);
 87 ⎥         }
 88 ⎥         self.allocator.destroy(self);
 89 ⎥     }
 90 ⎥ 
 91 ⎥     // Returns an error if already set.
 92 ⎥     pub fn set(self: *BackendPayload, values: Settings) !void {
 93 ⎥         if (self.is_set) {
 94 ⎥             return error.EditContactBackendPayloadAlreadySet;
 95 ⎥         }
 96 ⎥         self.is_set = true;
 97 ⎥         if (values.user_error_message) |user_error_message| {
 98 ⎥             self.user_error_message = try self.allocator.alloc(u8, user_error_message.len);
 99 ⎥             @memcpy(@constCast(self.user_error_message), user_error_message);
100 ⎥         }
101 ⎥     }
102 ⎥ };
103 ⎥ 
104 ⎥ /// This is the "EditContact" message.
105 ⎥ pub const Message = struct {
106 ⎥     allocator: std.mem.Allocator,
107 ⎥     count_pointers: *Counter,
108 ⎥     frontend_payload: *FrontendPayload,
109 ⎥     backend_payload: *BackendPayload,
110 ⎥ 
111 ⎥     // deinit does not deinit until self is the final pointer to Message.
112 ⎥     pub fn deinit(self: *Message) void {
113 ⎥         std.log.debug(" == Init msg.deinit()", .{});
114 ⎥         if (self.count_pointers.dec() > 0) {
115 ⎥             // There are more pointers.
116 ⎥             // See fn copy.
117 ⎥             return;
118 ⎥         }
119 ⎥         // This is the last existing pointer.
120 ⎥         self.allocator.destroy(self);
121 ⎥     }
122 ⎥ 
123 ⎥     /// KICKZIG TODO:
124 ⎥     /// copy pretends to create and return a copy of the message.
125 ⎥     /// The dispatcher sends a copy to each receiveFn.
126 ⎥     /// Each receiveFn owns the message copy and must deinit it.
127 ⎥     /// The back-end receiveFn must only send a copy to the front-end.
128 ⎥     /// Back-end Messenger Example:
129 ⎥     /// var return_copy = message.copy() catch |err| {
130 ⎥     ///     self.exit(@errorName(err));
131 ⎥     /// };
132 ⎥     /// // Set the back-end payload.
133 ⎥     /// return_copy.backend_payload.set(.{.name = record.name}) catch |err| {
134 ⎥     ///     self.exit(@errorName(err));
135 ⎥     /// };
136 ⎥     /// // Send the message copy to the front-end.
137 ⎥     /// // The channel's send function owns the copy and will deinit it.
138 ⎥     /// self.send_channels.EditContact.send(message) catch |err| {
139 ⎥     ///     self.exit(@errorName(err));
140 ⎥     /// };
141 ⎥     ///
142 ⎥     /// In this case copy does not return a copy of itself.
143 ⎥     /// In order to save memory space, it really only
144 ⎥     /// * increments the count of the number of pointers to this message.
145 ⎥     /// * returns self.
146 ⎥     /// See deinit().
147 ⎥     pub fn copy(self: *Message) !*Message {
148 ⎥         _ = self.count_pointers.inc();
149 ⎥         return self;
150 ⎥     }
151 ⎥ };
152 ⎥ 
153 ⎥ /// init creates an original message.
154 ⎥ pub fn init(allocator: std.mem.Allocator) !*Message {
155 ⎥     var self: *Message = try allocator.create(Message);
156 ⎥     self.frontend_payload = try FrontendPayload.init(allocator);
157 ⎥     errdefer {
158 ⎥         allocator.destroy(self);
159 ⎥     }
160 ⎥     self.backend_payload = try BackendPayload.init(allocator);
161 ⎥     errdefer {
162 ⎥         self.frontend_payload.deinit();
163 ⎥         allocator.destroy(self);
164 ⎥     }
165 ⎥     self.count_pointers = try Counter.init(allocator);
166 ⎥     errdefer {
167 ⎥         self.backend_payload.deinit();
168 ⎥         self.frontend_payload.deinit();
169 ⎥         allocator.destroy(self);
170 ⎥     }
171 ⎥     _ = self.count_pointers.inc();
172 ⎥     self.allocator = allocator;
173 ⎥     return self;
174 ⎥ }
175 ⎥ 
```

#### EditContact back-end messenger

The EditContact back-end messenger updates the store with the user's edits to the record. Then the EditContact back-end messenger triggers the RebuildContactList messenger.

```zig
  1 ⎥ /// This is the back-end's "EditContact" message handler.
  2 ⎥ /// This messenger can receive the "EditContact" message from the front-end
  3 ⎥ ///     and then if needed, send the "EditContact" message back to the front-end.
  4 ⎥ /// The "EditContact" message is at deps/message/src/EditContact.zig.
  5 ⎥ /// This file was generated by kickzig when you added the "EditContact" message.
  6 ⎥ /// This file will be removed by kickzig when you remove the "EditContact" message.
  7 ⎥ /// KICKZIG TODO: Customize fn receiveFn.
  8 ⎥ const std = @import("std");
  9 ⎥ 
 10 ⎥ const _channel_ = @import("channel");
 11 ⎥ const _message_ = @import("message");
 12 ⎥ const _startup_ = @import("startup");
 13 ⎥ const Store = @import("store").Store;
 14 ⎥ 
 15 ⎥ pub const Messenger = struct {
 16 ⎥     allocator: std.mem.Allocator,
 17 ⎥     send_channels: *_channel_.BackendToFrontend,
 18 ⎥     receive_channels: *_channel_.FrontendToBackend,
 19 ⎥     exit: *const fn (user_message: []const u8) void,
 20 ⎥     store: *Store,
 21 ⎥ 
 22 ⎥     pub fn deinit(self: *Messenger) void {
 23 ⎥         self.allocator.destroy(self);
 24 ⎥     }
 25 ⎥ 
 26 ⎥     /// receiveEditContactFn receives the "EditContact" message from the front-end.
 27 ⎥     /// It implements _channel_.FrontendToBackend.EditContact.Behavior.receiveFn found in deps/channel/fronttoback/EditContact.zig.
 28 ⎥     /// The receiveEditContactFn owns the message it receives.
 29 ⎥     pub fn receiveEditContactFn(implementor: *anyopaque, message: *_message_.EditContact.Message) ?anyerror {
 30 ⎥         var self: *Messenger = @alignCast(@ptrCast(implementor));
 31 ⎥         defer message.deinit();
 32 ⎥ 
 33 ⎥         self.receiveJob(message) catch |err| {
 34 ⎥             // Fatal error.
 35 ⎥             self.exit(@errorName(err));
 36 ⎥             return err;
 37 ⎥         };
 38 ⎥         // Send the send the reply to the front-end if required.
 39 ⎥         self.send_channels.EditContact.send(message) catch |err| {
 40 ⎥             // Fatal error.
 41 ⎥             self.exit(@errorName(err));
 42 ⎥             return err;
 43 ⎥         };
 44 ⎥ 
 45 ⎥         // No errors so return null;
 46 ⎥         return null;
 47 ⎥     }
 48 ⎥ 
 49 ⎥     /// receiveJob fullfills the front-end's request.
 50 ⎥     /// If there is missing record information set the user_error_message and returns.
 51 ⎥     /// else updates the record in the store.
 52 ⎥     fn receiveJob(self: *Messenger, message: *_message_.EditContact.Message) !void {
 53 ⎥         if (message.frontend_payload.contact) |contact| {
 54 ⎥             if (contact.name == null) {
 55 ⎥                 try message.backend_payload.set(
 56 ⎥                     .{ .user_error_message = "Name is a required field." },
 57 ⎥                 );
 58 ⎥                 return;
 59 ⎥             }
 60 ⎥             if (contact.address == null) {
 61 ⎥                 try message.backend_payload.set(
 62 ⎥                     .{ .user_error_message = "Address is a required field." },
 63 ⎥                 );
 64 ⎥                 return;
 65 ⎥             }
 66 ⎥             if (contact.city == null) {
 67 ⎥                 try message.backend_payload.set(
 68 ⎥                     .{ .user_error_message = "City is a required field." },
 69 ⎥                 );
 70 ⎥                 return;
 71 ⎥             }
 72 ⎥             if (contact.state == null) {
 73 ⎥                 try message.backend_payload.set(
 74 ⎥                     .{ .user_error_message = "State is a required field." },
 75 ⎥                 );
 76 ⎥                 return;
 77 ⎥             }
 78 ⎥             if (contact.zip == null) {
 79 ⎥                 try message.backend_payload.set(
 80 ⎥                     .{ .user_error_message = "Zip is a required field." },
 81 ⎥                 );
 82 ⎥                 return;
 83 ⎥             }
 84 ⎥             // Store the record.
 85 ⎥             try self.store.contact_table.update(contact.id, contact.name.?, contact.address.?, contact.city.?, contact.state.?, contact.zip.?);
 86 ⎥         } else {
 87 ⎥             return error.AddContactMessageMissingContact;
 88 ⎥         }
 89 ⎥     }
 90 ⎥ };
 91 ⎥ 
 92 ⎥ pub fn init(startup: _startup_.Backend) !*Messenger {
 93 ⎥     var messenger: *Messenger = try startup.allocator.create(Messenger);
 94 ⎥     messenger.allocator = startup.allocator;
 95 ⎥     messenger.send_channels = startup.send_channels;
 96 ⎥     messenger.receive_channels = startup.receive_channels;
 97 ⎥     var receive_behavior = try startup.receive_channels.EditContact.initBehavior();
 98 ⎥     errdefer {
 99 ⎥         messenger.deinit();
100 ⎥     }
101 ⎥     receive_behavior.implementor = messenger;
102 ⎥     receive_behavior.receiveFn = &Messenger.receiveEditContactFn;
103 ⎥     try startup.receive_channels.EditContact.subscribe(receive_behavior);
104 ⎥     errdefer {
105 ⎥         messenger.deinit();
106 ⎥     }
107 ⎥     messenger.exit = startup.exit;
108 ⎥     messenger.store = startup.store;
109 ⎥     return messenger;
110 ⎥ }
111 ⎥ 
```

### The RemoveContact message and back-end messenger

#### RemoveContact message

The RemoveContact message contains the id of a contact record that the user wants removed. Then the RemoveContact back-end messenger triggers the RebuildContactList messenger.

```zig
  1 ⎥ /// This file was generated by kickzig when you added the "RemoveContact" message.
  2 ⎥ /// This file will be removed by kickzig if you remove the "RemoveContact" message.
  3 ⎥ /// The "RemoveContact" message is:
  4 ⎥ /// * sent from the front-end to the back-end
  5 ⎥ /// * with the back-end possibly returning the message back to the front-end.
  6 ⎥ /// The front-end will:
  7 ⎥ /// 1. init this message.
  8 ⎥ /// 2. set the front-end payload.
  9 ⎥ /// 3. send the message to the back-end.
 10 ⎥ /// The back-end will:
 11 ⎥ /// 1. receive the message and do something with the data in the front-end payload.
 12 ⎥ /// 2. The back-end may also:
 13 ⎥ ///    i.   make a return copy.
 14 ⎥ ///    ii.  set the back-end payload.
 15 ⎥ ///    iii. send the return copy back to the front-end.
 16 ⎥ /// The front-end upon receiving the returned message:
 17 ⎥ ///    i.  will process the data in the back-end payload.
 18 ⎥ ///    ii. WILL NOT RETURN THE MESSAGE TO THE BACK-END.
 19 ⎥ const std = @import("std");
 20 ⎥ const Counter = @import("counter").Counter;
 21 ⎥ const Contact = @import("record").Remove;
 22 ⎥ 
 23 ⎥ // FrontendPayload is the "RemoveContact" message from the front-end to the back-end.
 24 ⎥ /// KICKZIG TODO: Add your own front-end payload fields and methods.
 25 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 26 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 27 ⎥ pub const FrontendPayload = struct {
 28 ⎥     allocator: std.mem.Allocator,
 29 ⎥     is_set: bool,
 30 ⎥ 
 31 ⎥     // The member foobar is presented as an example.
 32 ⎥     id: ?i64,
 33 ⎥ 
 34 ⎥     pub const Settings = struct {
 35 ⎥         id: ?i64,
 36 ⎥     };
 37 ⎥ 
 38 ⎥     fn init(allocator: std.mem.Allocator) !*FrontendPayload {
 39 ⎥         var self: *FrontendPayload = try allocator.create(FrontendPayload);
 40 ⎥         self.allocator = allocator;
 41 ⎥         self.is_set = false;
 42 ⎥         self.id = null;
 43 ⎥         return self;
 44 ⎥     }
 45 ⎥ 
 46 ⎥     fn deinit(self: *FrontendPayload) void {
 47 ⎥         self.allocator.destroy(self);
 48 ⎥     }
 49 ⎥ 
 50 ⎥     // Returns an error if already set.
 51 ⎥     pub fn set(self: *BackendPayload, values: Settings) !void {
 52 ⎥         if (self.is_set) {
 53 ⎥             return error.RemoveContactBackendPayloadAlreadySet;
 54 ⎥         }
 55 ⎥         self.is_set = true;
 56 ⎥         if (values.id) |id| {
 57 ⎥             self.id = try id;
 58 ⎥         }
 59 ⎥     }
 60 ⎥ };
 61 ⎥ 
 62 ⎥ // BackendPayload is the "RemoveContact" message from the back-end to the front-end.
 63 ⎥ /// KICKZIG TODO: Add your own back-end payload fields and methods.
 64 ⎥ /// KICKZIG TODO: Customize pub const Settings for your fields.
 65 ⎥ /// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
 66 ⎥ pub const BackendPayload = struct {
 67 ⎥     allocator: std.mem.Allocator = undefined,
 68 ⎥     is_set: bool,
 69 ⎥ 
 70 ⎥     // The member user_error_message is presented as an example.
 71 ⎥     user_error_message: ?[]const u8,
 72 ⎥ 
 73 ⎥     pub const Settings = struct {
 74 ⎥         user_error_message: ?[]const u8,
 75 ⎥     };
 76 ⎥ 
 77 ⎥     fn init(allocator: std.mem.Allocator) !*BackendPayload {
 78 ⎥         var self: *BackendPayload = try allocator.create(BackendPayload);
 79 ⎥         self.allocator = allocator;
 80 ⎥         self.user_error_message = null;
 81 ⎥         return self;
 82 ⎥     }
 83 ⎥ 
 84 ⎥     fn deinit(self: *BackendPayload) void {
 85 ⎥         if (self.user_error_message) |user_error_message| {
 86 ⎥             self.allocator.free(user_error_message);
 87 ⎥         }
 88 ⎥         self.allocator.destroy(self);
 89 ⎥     }
 90 ⎥ 
 91 ⎥     // Returns an error if already set.
 92 ⎥     pub fn set(self: *BackendPayload, values: Settings) !void {
 93 ⎥         if (self.is_set) {
 94 ⎥             return error.RemoveContactBackendPayloadAlreadySet;
 95 ⎥         }
 96 ⎥         self.is_set = true;
 97 ⎥         if (values.user_error_message) |user_error_message| {
 98 ⎥             self.user_error_message = self.allocator.alloc(u8, user_error_message.len);
 99 ⎥             @memcpy(@constCast(self.user_error_message), user_error_message);
100 ⎥         }
101 ⎥     }
102 ⎥ };
103 ⎥ 
104 ⎥ /// This is the "RemoveContact" message.
105 ⎥ pub const Message = struct {
106 ⎥     allocator: std.mem.Allocator,
107 ⎥     count_pointers: *Counter,
108 ⎥     frontend_payload: *FrontendPayload,
109 ⎥     backend_payload: *BackendPayload,
110 ⎥ 
111 ⎥     // deinit does not deinit until self is the final pointer to Message.
112 ⎥     pub fn deinit(self: *Message) void {
113 ⎥         std.log.debug(" == Init msg.deinit()", .{});
114 ⎥         if (self.count_pointers.dec() > 0) {
115 ⎥             // There are more pointers.
116 ⎥             // See fn copy.
117 ⎥             return;
118 ⎥         }
119 ⎥         // This is the last existing pointer.
120 ⎥         self.allocator.destroy(self);
121 ⎥     }
122 ⎥ 
123 ⎥     /// KICKZIG TODO:
124 ⎥     /// copy pretends to create and return a copy of the message.
125 ⎥     /// The dispatcher sends a copy to each receiveFn.
126 ⎥     /// Each receiveFn owns the message copy and must deinit it.
127 ⎥     /// The back-end receiveFn must only send a copy to the front-end.
128 ⎥     /// Back-end Messenger Example:
129 ⎥     /// var return_copy = message.copy() catch |err| {
130 ⎥     ///     self.exit(@errorName(err));
131 ⎥     /// };
132 ⎥     /// // Set the back-end payload.
133 ⎥     /// return_copy.backend_payload.set(.{.name = record.name}) catch |err| {
134 ⎥     ///     self.exit(@errorName(err));
135 ⎥     /// };
136 ⎥     /// // Send the message copy to the front-end.
137 ⎥     /// // The channel's send function owns the copy and will deinit it.
138 ⎥     /// self.send_channels.RemoveContact.send(message) catch |err| {
139 ⎥     ///     self.exit(@errorName(err));
140 ⎥     /// };
141 ⎥     ///
142 ⎥     /// In this case copy does not return a copy of itself.
143 ⎥     /// In order to save memory space, it really only
144 ⎥     /// * increments the count of the number of pointers to this message.
145 ⎥     /// * returns self.
146 ⎥     /// See deinit().
147 ⎥     pub fn copy(self: *Message) !*Message {
148 ⎥         _ = self.count_pointers.inc();
149 ⎥         return self;
150 ⎥     }
151 ⎥ };
152 ⎥ 
153 ⎥ /// init creates an original message.
154 ⎥ pub fn init(allocator: std.mem.Allocator) !*Message {
155 ⎥     var self: *Message = try allocator.create(Message);
156 ⎥     self.frontend_payload = try FrontendPayload.init(allocator);
157 ⎥     errdefer {
158 ⎥         allocator.destroy(self);
159 ⎥     }
160 ⎥     self.backend_payload = try BackendPayload.init(allocator);
161 ⎥     errdefer {
162 ⎥         self.frontend_payload.deinit();
163 ⎥         allocator.destroy(self);
164 ⎥     }
165 ⎥     self.count_pointers = try Counter.init(allocator);
166 ⎥     errdefer {
167 ⎥         self.backend_payload.deinit();
168 ⎥         self.frontend_payload.deinit();
169 ⎥         allocator.destroy(self);
170 ⎥     }
171 ⎥     _ = self.count_pointers.inc();
172 ⎥     self.allocator = allocator;
173 ⎥     return self;
174 ⎥ }
175 ⎥ 
```

#### RemoveContact back-end messenger

The RemoveContact back-end messenger removes the user selected contact record from the store.

```zig
  1 ⎥ /// This is the back-end's "RemoveContact" message handler.
  2 ⎥ /// This messenger can receive the "RemoveContact" message from the front-end
  3 ⎥ ///     and then if needed, send the "RemoveContact" message back to the front-end.
  4 ⎥ /// The "RemoveContact" message is at deps/message/src/RemoveContact.zig.
  5 ⎥ /// This file was generated by kickzig when you added the "RemoveContact" message.
  6 ⎥ /// This file will be removed by kickzig when you remove the "RemoveContact" message.
  7 ⎥ /// KICKZIG TODO: Customize fn receiveFn.
  8 ⎥ const std = @import("std");
  9 ⎥ const Store = @import("store").Store;
 10 ⎥ 
 11 ⎥ const _channel_ = @import("channel");
 12 ⎥ const _message_ = @import("message");
 13 ⎥ const _startup_ = @import("startup");
 14 ⎥ 
 15 ⎥ pub const Messenger = struct {
 16 ⎥     allocator: std.mem.Allocator,
 17 ⎥     send_channels: *_channel_.BackendToFrontend,
 18 ⎥     receive_channels: *_channel_.FrontendToBackend,
 19 ⎥     exit: *const fn (user_message: []const u8) void,
 20 ⎥     store: *Store,
 21 ⎥ 
 22 ⎥     pub fn deinit(self: *Messenger) void {
 23 ⎥         self.allocator.destroy(self);
 24 ⎥     }
 25 ⎥ 
 26 ⎥     /// receiveRemoveContactFn receives the "RemoveContact" message from the front-end.
 27 ⎥     /// It implements _channel_.FrontendToBackend.RemoveContact.Behavior.receiveFn found in deps/channel/fronttoback/RemoveContact.zig.
 28 ⎥     /// The receiveRemoveContactFn owns the message it receives.
 29 ⎥     pub fn receiveRemoveContactFn(implementor: *anyopaque, message: *_message_.RemoveContact.Message) ?anyerror {
 30 ⎥         var self: *Messenger = @alignCast(@ptrCast(implementor));
 31 ⎥         defer message.deinit();
 32 ⎥ 
 33 ⎥         self.receiveJob(message) catch |err| {
 34 ⎥             // Fatal error.
 35 ⎥             self.exit(@errorName(err));
 36 ⎥             return err;
 37 ⎥         };
 38 ⎥         // Send the send the reply to the front-end if required.
 39 ⎥         self.send_channels.RemoveContact.send(message) catch |err| {
 40 ⎥             // Fatal error.
 41 ⎥             self.exit(@errorName(err));
 42 ⎥             return err;
 43 ⎥         };
 44 ⎥ 
 45 ⎥         // No errors so return null;
 46 ⎥         return null;
 47 ⎥     }
 48 ⎥ 
 49 ⎥     /// receiveJob fullfills the front-end's request.
 50 ⎥     /// Removes the record from the store.
 51 ⎥     fn receiveJob(self: *Messenger, message: *_message_.RemoveContact.Message) !void {
 52 ⎥         if (message.frontend_payload.id) |id| {
 53 ⎥             return self.store.contact_table.remove(id);
 54 ⎥         } else {
 55 ⎥             return error.RebuildContactListMissingID;
 56 ⎥         }
 57 ⎥     }
 58 ⎥ };
 59 ⎥ 
 60 ⎥ pub fn init(startup: _startup_.Backend) !*Messenger {
 61 ⎥     var messenger: *Messenger = try startup.allocator.create(Messenger);
 62 ⎥     messenger.allocator = startup.allocator;
 63 ⎥     messenger.send_channels = startup.send_channels;
 64 ⎥     messenger.receive_channels = startup.receive_channels;
 65 ⎥     var receive_behavior = try startup.receive_channels.RemoveContact.initBehavior();
 66 ⎥     errdefer {
 67 ⎥         messenger.deinit();
 68 ⎥     }
 69 ⎥     receive_behavior.implementor = messenger;
 70 ⎥     receive_behavior.receiveFn = &Messenger.receiveRemoveContactFn;
 71 ⎥     try startup.receive_channels.RemoveContact.subscribe(receive_behavior);
 72 ⎥     errdefer {
 73 ⎥         messenger.deinit();
 74 ⎥     }
 75 ⎥     messenger.exit = startup.exit;
 76 ⎥     messenger.store = startup.store;
 77 ⎥     return messenger;
 78 ⎥ }
 79 ⎥ 
```
