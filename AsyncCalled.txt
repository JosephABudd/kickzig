
// AsyncFn1CBParams is each parameter of AsyncFn1's call back.
// The member values are the arguments passed to AsyncFn1's call back.
const AsyncFn1CBParams = struct {
    allocator: std.mem.Allocator,
    i: u8,

    pub fn init(allocator: std.mem.Allocator) !*CBStateFn1 {
        var args: *AsyncFn1CBParams = &AsyncFn1CBParams{
            allocator: allocator,
            i: 0,
        }
        return state;
    }

    fn deinit(self: *AsyncFn1CBParams) {
        self.free(self.name);
        self.allocator.destroy(self);
    }

    // free gets the params ready for another call back.
    fn free(self: *AsyncFn1CBParams) void {
        // self.allocator.free(self.name);
        self.i = 0;
    }

}

pub const Something struct = {
    allocator: std.mem.Allocator,

    fn init(allocator: std.mem.Allocator) !*Something {
        var something: *Something = &Something{};
        something.allocator = allocator;
        return something;
    }

    fn AsyncFn1(
        self: *Something,
        caller_self: *anyopaque,
        caller_state: *anyopaque,
        call_back: *const fn(self: *anyopaque, state_ptr: *anyopaque, args: *AsyncFn1CBParams) !void,
        free_state: *const fn(self_ptr: *anyopaque, state_ptr: *anyopaque) void,
    ) !void {
        // Remember to free the caller's state and finalize anything else.
        defer free_state(caller_self, caller_state);
        // Set the call_backs's arguments.
        var args: *AsyncFn1CBParams = AsyncFn1CBParams.init(self.allocator);
        defer args.deinit();
        for (0..5) |i| {
            args.i = i;
            try call_back(caller_self, caller_state, args);
            args.free();
        }
    }
}
