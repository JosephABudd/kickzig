const std = @import("std");
const fmt = std.fmt;

pub const Template = struct {
    allocator: std.mem.Allocator,
    channel_name: []const u8,

    pub fn deinit(self: *Template) void {
        self.allocator.free(self.channel_name);
        self.allocator.destroy(self);
    }

    // The caller owns the returned value.
    pub fn content(self: *Template) ![]const u8 {
        // Replace {{ channel_name }} with the message name.
        const replacement_size: usize = std.mem.replacementSize(u8, template, "{{ channel_name }}", self.channel_name);
        const with_channel_name: []u8 = try self.allocator.alloc(u8, replacement_size);
        _ = std.mem.replace(u8, template, "{{ channel_name }}", self.channel_name, with_channel_name);
        return with_channel_name;
    }
};

pub fn init(allocator: std.mem.Allocator, name: []const u8) !*Template {
    var data: *Template = try allocator.create(Template);
    data.channel_name = try allocator.alloc(u8, name.len);
    errdefer allocator.destroy(data);
    @memcpy(@constCast(data.channel_name), name);
    data.allocator = allocator;
    return data;
}

const template =
    \\/// Through this channel:
    \\/// Messages flow from the front-end to the back-end:
    \\/// 1. Any front-end messenger can send a "{{ channel_name }}" message to the subscribed back-end "{{ channel_name }}" messenger.
    \\/// 2. The subscribed back-end "{{ channel_name }}" messenger receives each "{{ channel_name }}" message sent from any front-end messengers.
    \\/// This file was generated by kickzig when you added the "{{ channel_name }}" message.
    \\/// It will be removed when you remove the "{{ channel_name }}" message.
    \\const std = @import("std");
    \\
    \\pub const _message_ = @import("message").{{ channel_name }};
    \\
    \\/// Behavior is back-end messenger's call-backs and state.
    \\/// .implementor implements the recieveFn and triggerFn.
    \\/// .receiveFn receives a {{ channel_name }} message from the front-end.
    \\pub const Behavior = struct {
    \\    implementor: *anyopaque,
    \\    receiveFn: *const fn (implementor: *anyopaque, message: *_message_.Message) ?anyerror,
    \\};
    \\
    \\pub const Group = struct {
    \\    allocator: std.mem.Allocator = undefined,
    \\    members: std.AutoHashMap(*anyopaque, *Behavior),
    \\    exit: *const fn (user_message: []const u8) void,
    \\
    \\    /// initBehavior constructs an empty Behavior.
    \\    pub fn initBehavior(self: *Group) !*Behavior {
    \\        return self.allocator.create(Behavior);
    \\    }
    \\
    \\    pub fn deinit(self: *Group) void {
    \\        // deint each Behavior.
    \\        var iterator = self.members.iterator();
    \\        while (iterator.next()) |entry| {
    \\            var behavior: *Behavior = @ptrCast(entry.value_ptr.*);
    \\            self.allocator.destroy(behavior);
    \\        }
    \\        self.members.deinit();
    \\        self.allocator.destroy(self);
    \\    }
    \\
    \\    /// subscribe adds a back-end messenger's Behavior that will receiver the message to the Group.
    \\    /// Group owns the Behavior not the caller.
    \\    /// So if there is an error the Behavior is destroyed.
    \\    pub fn subscribe(self: *Group, behavior: *Behavior) !void {
    \\        self.members.put(behavior.implementor, behavior) catch |err| {
    \\            self.allocator.destroy(behavior);
    \\            return err;
    \\        };
    \\    }
    \\
    \\    /// unsubscribe removes a back-end messenger's Behavior from the Group.
    \\    /// It also destroys the Behavior.
    \\    /// Returns true if anything was removed.
    \\    pub fn unsubscribe(self: *Group, caller: *anyopaque) bool {
    \\        if (self.members.getEntry(caller)) |entry| {
    \\            var behavior: *Behavior = @ptrCast(entry.value_ptr.*);
    \\            self.allocator.destroy(behavior);
    \\            return self.members.remove(caller);
    \\        }
    \\    }
    \\
    \\    /// send dispatches the message to the back-end messenger Behaviors in Group.
    \\    /// It dispatches in another thread.
    \\    /// It returns after spawning the thread while the thread runs.
    \\    /// It takes control of the message and deinits it.
    \\    /// Receive functions own the message they receive and must deinit it.
    \\    pub fn send(self: *Group, message: *_message_.Message) !void {
    \\        var copy: *_message_.Message = try message.copy();
    \\        var thread = try std.Thread.spawn(.{ .allocator = self.allocator }, Group.dispatchDeinit, .{ self, copy });
    \\        std.Thread.detach(thread);
    \\    }
    \\
    \\    fn dispatchDeinit(self: *Group, message: *_message_.Message) void {
    \\        defer message.deinit();
    \\
    \\        var iterator = self.members.iterator();
    \\        while (iterator.next()) |entry| {
    \\            var behavior: *Behavior = entry.value_ptr.*;
    \\            // Send the receiver a copy of the message.
    \\            // The receiver owns the copy and must deinit it.
    \\            var receiver_copy: *_message_.Message = message.copy() catch |err| {
    \\                self.exit(@errorName(err));
    \\                return;
    \\            };
    \\            if (behavior.receiveFn(behavior.implementor, receiver_copy)) |_| {
    \\                // Error: Stop dispatching.
    \\                break;
    \\            }
    \\        }
    \\    }
    \\};
    \\
    \\pub fn init(allocator: std.mem.Allocator, exit: *const fn (user_message: []const u8) void) !*Group {
    \\    var channel: *Group = try allocator.create(Group);
    \\    channel.members = std.AutoHashMap(*anyopaque, *Behavior).init(allocator);
    \\    channel.allocator = allocator;
    \\    channel.exit = exit;
    \\    return channel;
    \\}
    \\
;
