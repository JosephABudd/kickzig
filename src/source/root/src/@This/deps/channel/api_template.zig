const std = @import("std");
const fmt = std.fmt;

pub const Template = struct {
    allocator: std.mem.Allocator,
    channel_names: [][]const u8,
    channel_names_index: usize,

    pub fn init(allocator: std.mem.Allocator) !*Template {
        var data: *Template = try allocator.create(Template);
        data.channel_names = try allocator.alloc([]const u8, 5);
        errdefer {
            allocator.destroy(data);
        }
        data.channel_names_index = 0;
        data.allocator = allocator;
        return data;
    }

    pub fn deinit(self: *Template) void {
        for (self.channel_names, 0..) |name, i| {
            if (i == self.channel_names_index) {
                break;
            }
            self.allocator.free(name);
        }
        self.allocator.free(self.channel_names);
        self.allocator.destroy(self);
    }

    pub fn addName(self: *Template, new_name: []const u8) !void {
        var new_channel_names: [][]const u8 = undefined;
        if (self.channel_names_index == self.channel_names.len) {
            // Full list so create a new bigger one.
            new_channel_names = try self.allocator.alloc([]const u8, (self.channel_names.len + 5));
            for (self.channel_names, 0..) |name, i| {
                new_channel_names[i] = name;
            }
            // Replace the old list with the new bigger one.
            self.allocator.free(self.channel_names);
            self.channel_names = new_channel_names;
        }
        self.channel_names[self.channel_names_index] = try self.allocator.alloc(u8, new_name.len);
        @memcpy(@constCast(self.channel_names[self.channel_names_index]), new_name);
        self.channel_names_index += 1;
    }

    pub fn content(self: *Template) ![]const u8 {
        var line: []u8 = undefined;
        var lines = std.ArrayList(u8).init(self.allocator);
        defer lines.deinit();
        try lines.appendSlice(line1);
        var names: [][]const u8 = self.channel_names[0..self.channel_names_index];
        if (names.len > 0) {
            try lines.appendSlice("\n");
        }
        for (names) |name| {
            line = try fmt.allocPrint(self.allocator, "const _{0s}_ = @import(\"{0s}.zig\");\n", .{name});
            defer self.allocator.free(line);
            try lines.appendSlice(line);
        }
        try lines.appendSlice(line2);
        for (names) |name| {
            line = try fmt.allocPrint(self.allocator, "    {0s}: *_{0s}_.Group,\n", .{name});
            defer self.allocator.free(line);
            try lines.appendSlice(line);
        }
        try lines.appendSlice(line3a);
        for (names) |name| {
            {
                line = try fmt.allocPrint(self.allocator, "        self.{0s}.deinit();\n", .{name});
                defer self.allocator.free(line);
                try lines.appendSlice(line);
            }
        }
        try lines.appendSlice(line3b);
        for (names, 0..) |name, i| {
            {
                line = try fmt.allocPrint(self.allocator, "channels.{0s} = _{0s}_.init(allocator) catch |err| {{\n", .{name});
                defer self.allocator.free(line);
                try lines.appendSlice(line);
            }
            try lines.appendSlice("    channels.Fatal.deinit();\n");
            try lines.appendSlice("    channels.Initialize.deinit();\n");
            try lines.appendSlice("\n");
            var deinit_names: [][]const u8 = names[0..i];
            for (deinit_names) |deinit_name| {
                line = try fmt.allocPrint(self.allocator, "    channels.{0s}.deinit();\n", .{deinit_name});
                defer self.allocator.free(line);
                try lines.appendSlice(line);
            }
            try lines.appendSlice("    allocator.destroy(channels);\n");
            try lines.appendSlice("    return err;\n");
            try lines.appendSlice("}}\n");
            try lines.appendSlice("\n");
        }
        try lines.appendSlice(line4);
        return try lines.toOwnedSlice();
    }
};

const line1: []const u8 =
    \\// This file is re-generated by kickzig when a message is added or removed.
    \\// DO NOT EDIT THIS FILE.
    \\const std = @import("std");
    \\const testing = std.testing;
    \\
    \\const _Initialize_ = @import("Initialize.zig");
    \\const _Fatal_ = @import("Fatal.zig");
    \\
;
// \\const _Add_ = @import("src/Add.zig");
// \\const _Edit_ = @import("src/Edit.zig");
// \\const _Remove_ = @import("src/Remove.zig");
// \\

const line2: []const u8 =
    \\
    \\/// Channels is each message's channel.
    \\pub const Channels = struct {
    \\    allocator: std.mem.Allocator,
    \\
    \\    // Default channels.
    \\    Initialize: *_Initialize_.Group,
    \\    Fatal: *_Fatal_.Group,
    \\
    \\    // Custom channels.
    \\
;
// Add: *_Add_.Group,
// Edit: *_Edit_.Group,
// Remove: *_Remove_.Group,

const line3a =
    \\
    \\    pub fn deinit(self: *Channels) void {
    \\        self.Initialize.deinit();
    \\        self.Fatal.deinit();
;
// self.Add.deinit();
// self.Edit.deinit();
// self.Remove.deinit();

const line3b =
    \\        self.allocator.destroy(self);
    \\    }
    \\};
    \\
    \\pub fn init(allocator: std.mem.Allocator) !*Channels {
    \\    var channels: *Channels = try allocator.create(Channels);
    \\    channels.allocator = allocator;
    \\
    \\    // Defaults.
    \\    channels.Initialize = _Initialize_.init(allocator) catch |err| {
    \\        allocator.destroy(channels);
    \\        return err;
    \\    };
    \\    channels.Fatal = _Fatal_.init(allocator) catch |err| {
    \\        channels.Initialize.deinit();
    \\        allocator.destroy(channels);
    \\        return err;
    \\    };
    \\
    \\
;
// channels.Add = _Add_.init(allocator) catch |err| {
//     channels.Fatal.deinit();
//     channels.Initialize.deinit();
//     allocator.destroy(channels);
//     return err;
// };

// channels.Edit = _Edit_.init(allocator) catch |err| {
//     channels.Add.deinit();
//     channels.Fatal.deinit();
//     channels.Initialize.deinit();
//     allocator.destroy(channels);
//     return err;
// };

// channels.Remove = _Remove_.init(allocator) catch |err| {
//     channels.Edit.deinit();
//     channels.Add.deinit();
//     channels.Fatal.deinit();
//     channels.Initialize.deinit();
//     allocator.destroy(channels);
//     return err;
// };

const line4 =
    \\
    \\    return channels;
    \\}
    \\
    \\
;
