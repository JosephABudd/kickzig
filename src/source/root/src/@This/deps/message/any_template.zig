const std = @import("std");

pub const Template = struct {
    allocator: std.mem.Allocator,
    message_name: []const u8,

    pub fn deinit(self: *Template) void {
        self.allocator.free(self.message_name);
        self.allocator.destroy(self);
    }

    // The caller owns the returned value.
    pub fn content(self: *Template) ![]const u8 {
        // Replace {{ message_name }} with the message name.
        var replacement_size: usize = std.mem.replacementSize(u8, template, "{{ message_name }}", self.message_name);
        var with_message_name: []u8 = try self.allocator.alloc(u8, replacement_size);
        _ = std.mem.replace(u8, template, "{{ message_name }}", self.message_name, with_message_name);
        return with_message_name;
    }
};

pub fn init(allocator: std.mem.Allocator, name: []const u8) !*Template {
    var data: *Template = try allocator.create(Template);
    data.message_name = try allocator.alloc(u8, name.len);
    errdefer allocator.destroy(data);
    @memcpy(@constCast(data.message_name), name);
    data.allocator = allocator;
    return data;
}

const template =
    \\/// This file was generated by kickzig when you added the "{{ message_name }}" message.
    \\/// This file will be removed by kickzig if you remove the "{{ message_name }}" message.
    \\const std = @import("std");
    \\
    \\/// Counter is used to keep track of the number of pointers a message has.
    \\/// It is thread safe.
    \\pub const Counter = struct {
    \\    allocator: std.mem.Allocator,
    \\    mutex: std.Thread.Mutex,
    \\    counter: usize,
    \\
    \\    fn init(allocator: std.mem.Allocator) !*Counter {
    \\        var self: *Counter = try allocator.create(Counter);
    \\        self.allocator = allocator;
    \\        self.mutex = std.Thread.Mutex{};
    \\        self.counter = 0;
    \\        return self;
    \\    }
    \\
    \\    fn deinit(self: *Counter) void {
    \\        self.allocator.destroy(self);
    \\    }
    \\
    \\    fn inc(self: *Counter) usize {
    \\        self.mutex.lock();
    \\        defer self.mutex.unlock();
    \\        self.counter += 1;
    \\        return self.counter;
    \\    }
    \\
    \\    fn dec(self: *Counter) usize {
    \\        self.mutex.lock();
    \\        defer self.mutex.unlock();
    \\        if (self.counter > 0) {
    \\            self.counter -= 1;
    \\        }
    \\        return self.counter;
    \\    }
    \\
    \\    fn count(self: *Counter) usize {
    \\        self.mutex.lock();
    \\        defer self.mutex.unlock();
    \\        return self.counter;
    \\    }
    \\};
    \\
    \\// FrontendPayload is the "{{ message_name }}" message from the front-end to the back-end.
    \\/// KICKZIG TODO: Add your own front-end payload fields and methods.
    \\/// KICKZIG TODO: Customize pub const Settings for your fields.
    \\/// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
    \\pub const FrontendPayload = struct {
    \\    allocator: std.mem.Allocator,
    \\
    \\    // The member foobar is presented as an example.
    \\    foobar: ?[]const u8 = null,
    \\
    \\    pub const Settings = struct {
    \\        foobar: ?[]const u8 = null,
    \\    };
    \\
    \\    fn init(allocator: std.mem.Allocator) !*FrontendPayload {
    \\        var self: *FrontendPayload = try allocator.create(FrontendPayload);
    \\        self.allocator = allocator;
    \\        self.foobar = null;
    \\        return self;
    \\    }
    \\
    \\    fn deinit(self: *FrontendPayload) void {
    \\        if (self.foobar) |foobar| {
    \\            self.allocator.free(foobar);
    \\        }
    \\        self.allocator.destroy(self);
    \\    }
    \\
    \\    // Returns an error if frees or deinits are required.
    \\    pub fn set(self: *FrontendPayload, values: Settings) !void {
    \\        if (values.foobar) |foobar| {
    \\            if (self.foobar != null) {
    \\                return error.IllegalFrontendReset;
    \\            }
    \\            self.foobar = try self.allocator.alloc(u8, foobar.len);
    \\            @memcpy(@constCast(self.foobar), foobar);
    \\        }
    \\    }
    \\};
    \\
    \\// BackendPayload is the "{{ message_name }}" message from the back-end to the front-end.
    \\/// KICKZIG TODO: Add your own back-end payload fields and methods.
    \\/// KICKZIG TODO: Customize pub const Settings for your fields.
    \\/// KICKZIG TODO: Customize fn init(...), fn deinit(...) and pub fn set(...) for your fields.
    \\pub const BackendPayload = struct {
    \\    allocator: std.mem.Allocator = undefined,
    \\
    \\    // The member foofoo is presented as an example.
    \\    foofoo: ?[]const u8 = null,
    \\
    \\    pub const Settings = struct {
    \\        foofoo: ?[]const u8,
    \\    };
    \\
    \\    fn init(allocator: std.mem.Allocator) !*BackendPayload {
    \\        var self: *BackendPayload = try allocator.create(BackendPayload);
    \\        self.allocator = allocator;
    \\        self.foofoo = null;
    \\        return self;
    \\    }
    \\
    \\    fn deinit(self: *BackendPayload) void {
    \\        if (self.foofoo) |foofoo| {
    \\            self.allocator.free(foofoo);
    \\        }
    \\        self.allocator.destroy(self);
    \\    }
    \\
    \\    // Returns an error if frees or deinits are required.
    \\    pub fn set(self: *BackendPayload, values: Settings) !void {
    \\        // Initialize the back end payload using the values.
    \\        if (values.foofoo) |foofoo| {
    \\            if (self.foofoo != null) {
    \\                return error.IllegalBackendReset;
    \\            }
    \\            self.foofoo = try self.allocator.alloc(u8, foofoo.len);
    \\            @memcpy(@constCast(self.foofoo), foofoo);
    \\        }
    \\    }
    \\};
    \\
    \\/// This is the "{{ message_name }}" message.
    \\pub const Message = struct {
    \\    allocator: std.mem.Allocator,
    \\    count_pointers: *Counter,
    \\
    \\    frontend_payload: *FrontendPayload,
    \\    backend_payload: *BackendPayload,
    \\
    \\    // deinit does not deinit until self is the final pointer to Message.
    \\    pub fn deinit(self: *Message) void {
    \\        if (self.count_pointers.dec() > 0) {
    \\            // There are more pointers.
    \\            // So destroy this *Message but not the counter or payloads.
    \\            self.allocator.destroy(self);
    \\            return;
    \\        }
    \\        // This is the last existing pointer.
    \\        // Deinit everything.
    \\        self.count_pointers.deinit();
    \\        self.frontend_payload.deinit();
    \\        self.backend_payload.deinit();
    \\        self.allocator.destroy(self);
    \\    }
    \\
    \\    /// KICKZIG TODO:
    \\    /// returnCopy creates a copy of a received message which can be returned.
    \\    /// For example: If the front-end sends a message with a request, the backend will...
    \\    /// return_copy = try message.returnCopy();
    \\    /// try return_copy.backend_payload.set(.{.name = record.name});
    \\    /// In this case returnCopy
    \\    /// * increments the count of the number of pointers to this message.
    \\    /// * returns self.
    \\    /// See deinit().
    \\    /// Once a return copy is sent it is owned by the sending channel which will deinit it.
    \\    /// As written, returnCopy assumes
    \\    /// * the message is shared by all receivers.
    \\    /// * receivers will not alter unless authorized.
    \\    /// returnCopy is thread safe.
    \\    pub fn returnCopy(self: *Message) !*Message {
    \\        self.count_pointers.inc();
    \\        return self;
    \\    }
    \\};
    \\
    \\/// init creates an original message.
    \\/// After you init and probably set a message, you can send it.
    \\/// Once any message is sent, it is owned by the sending channel which will deinit it.
    \\pub fn init(allocator: std.mem.Allocator) !*Message {
    \\    var self: *Message = try allocator.create(Message);
    \\    self.frontend_payload = try FrontendPayload.init(allocator);
    \\    errdefer {
    \\        allocator.destroy(self);
    \\    }
    \\    self.backend_payload = try BackendPayload.init(allocator);
    \\    errdefer {
    \\        self.frontend_payload.deinit();
    \\        allocator.destroy(self);
    \\    }
    \\    self.count_pointers = try Counter.init(allocator);
    \\    errdefer {
    \\        self.backend_payload.deinit();
    \\        self.frontend_payload.deinit();
    \\        allocator.destroy(self);
    \\    }
    \\    _ = self.count_pointers.inc();
    \\    self.allocator = allocator;
    \\    return self;
    \\}
;
