const std = @import("std");
const fmt = std.fmt;
const strings = @import("strings");

pub const Template = struct {
    allocator: std.mem.Allocator,
    message_name: *strings.UTF8,

    pub fn init(allocator: std.mem.Allocator, name: []const u8) !*Template {
        var data: *Template = try allocator.create(Template);
        data.message_name = try allocator.alloc(u8, name.len);
        errdefer allocator.destroy(data);
        @memcpy(data.message_name, name);
        data.allocator = allocator;
        return data;
    }

    pub fn deinit(self: *Template) void {
        self.message_name.deinit();
        self.allocator.destroy(self);
    }

    pub fn content(self: *Template) ![]const u8 {
        // Replace {{message_name}} with the message name.
        const copy: []const u8 = self.message_name.copy();
        defer self.allocator.free(copy);
        var replacement_size: usize = try std.mem.replacementSize(u8, self.allocator, template, "{{message_name}}", copy);
        var with_message_name: []u8 = try self.allocator.alloc(replacement_size);
        defer self.allocator.free(with_message_name);
        try std.mem.replace(u8, template, "{{message_name}}", copy, with_message_name);
        // Replace {{a}} with "a" / "an".
        const a: []const u8 = self.message_name.aAn();
        defer self.allocator.free(a);
        replacement_size = try std.mem.replacementSize(u8, with_message_name, "{{a}}", a);
        var with_a: []const u8 = try self.allocator.alloc(replacement_size);
        try std.mem.replace(u8, with_message_name, "{{a}}", a, with_a);
        return with_a;
    }
};

const template =
    \\/// This is the back-end's "{{message_name}}" message handler.
    \\/// It receives and processes the "{{message_name}}" message.
    \\/// The "{{message_name}}" message is at deps/message/src/{{message_name}}.zig.
    \\/// This file was generated by kickzig when you added the "{{message_name}}" message.
    \\/// This file will be removed by kickzig when you remove the "{{message_name}}" message.
    \\/// KICKZIG TODO: Customize fn receiveFn.
    \\const std = @import("std");
    \\
    \\const _channel_ = @import("channel");
    \\const _message_ = @import("message");
    \\
    \\pub const Messenger = struct {
    \\    allocator: std.mem.Allocator,
    \\    send_channels: *_channel_.Channels,
    \\
    \\    pub fn deinit(self: *Messenger) void {
    \\        self.allocator.destroy(self);
    \\    }
    \\
    \\    /// receiveFn receives {{a}} "{{message_name}}" message from the front-end.
    \\    /// It implements _channel_.Channels.{{message_name}}.Behavior.receiveFn found in deps/channel/src/{{message_name}}.zig.
    \\    /// receiveFn does not control the received {{message_name}} message because only message dispatchers control messages.
    \\    /// For that reason:
    \\    /// * data from param add_message must be copied to be preserved.
    \\    /// * param add_message can safely be sent back to the front-end.
    \\    pub fn receiveFn(self_ptr: *anyopaque, add_message: *_message_.{{message_name}}.Message) void {
    \\        var self: *Messenger = @alignCast(@ptrCast(self_ptr));
    \\        _ = self;
    \\        _ = add_message;
    \\
    \\    }
    \\};
    \\
    \\pub fn init(allocator: std.mem.Allocator, send_channels: *_channel_.Channels, receive_channels: *_channel_.Channels) !*Messenger {
    \\    var messenger: *Messenger = try allocator.create(Messenger);
    \\    messenger.allocator = allocator;
    \\    messenger.send_channels = send_channels;
    \\    var behavior = try receive_channels.{{message_name}}.initBehavior();
    \\    errdefer {
    \\        messenger.deinit();
    \\    }
    \\    behavior.self = messenger;
    \\    behavior.receiveFn = &Messenger.receiveFn;
    \\    try receive_channels.{{message_name}}.subscribe(behavior);
    \\    errdefer {
    \\        messenger.deinit();
    \\    }
    \\    return messenger;
    \\}
    \\
;
