const std = @import("std");
const fmt = std.fmt;

pub const Template = struct {
    allocator: std.mem.Allocator,
    message_name: []const u8,

    pub fn deinit(self: *Template) void {
        self.allocator.free(self.message_name);
        self.allocator.destroy(self);
    }

    // The caller owns the returned value.
    pub fn content(self: *Template) ![]const u8 {
        return fmt.allocPrint(self.allocator, template, .{self.message_name});
    }
};

/// message name {0s}
// The caller owns the returned value.
pub fn init(allocator: std.mem.Allocator, name: []const u8) !*Template {
    var data: *Template = try allocator.create(Template);
    data.message_name = try allocator.alloc(u8, name.len);
    errdefer allocator.destroy(data);
    @memcpy(@constCast(data.message_name), name);
    data.allocator = allocator;
    return data;
}

const template =
    \\/// This is the back-end's "{0s}" message handler.
    \\/// 1 This messenger can receive the "{0s}" message from the front-end.
    \\///     and then if needed, send the "{0s}" message back to the front-end.
    \\/// 2 This messenger can also be triggered to send a default "{0s}" message to the front-end.
    \\/// The "{0s}" message is at deps/message/src/{0s}.zig.
    \\/// This file was generated by kickzig when you added the "{0s}" message.
    \\/// This file will be removed by kickzig when you remove the "{0s}" message.
    \\/// KICKZIG TODO: Customize fn receiveFn.
    \\const std = @import("std");
    \\
    \\const _channel_ = @import("channel");
    \\const _startup_ = @import("startup");
    \\
    \\const ExitFn = @import("various").ExitFn;
    \\const Message = @import("message").{0s};
    \\
    \\pub const Messenger = struct {{
    \\    allocator: std.mem.Allocator,
    \\    send_channels: *_channel_.BackendToFrontend,
    \\    receive_channels: *_channel_.FrontendToBackend,
    \\    triggers: *_channel_.Trigger,
    \\    exit: ExitFn,
    \\
    \\    pub fn init(startup: _startup_.Backend) !*Messenger {{
    \\        var messenger: *Messenger = try startup.allocator.create(Messenger);
    \\        messenger.allocator = startup.allocator;
    \\        messenger.send_channels = startup.send_channels;
    \\        messenger.receive_channels = startup.receive_channels;
    \\        messenger.triggers = startup.triggers;
    \\        messenger.exit = startup.exit;
    \\    
    \\        // Subscribe to receive the {0s} message.
    \\        var receive_behavior = try startup.receive_channels.{0s}.initBehavior();
    \\        errdefer {{
    \\            messenger.deinit();
    \\        }}
    \\        receive_behavior.implementor = messenger;
    \\        receive_behavior.receiveFn = &Messenger.receive{0s}Fn;
    \\        try startup.receive_channels.{0s}.subscribe(receive_behavior);
    \\        errdefer {{
    \\            messenger.deinit();
    \\        }}
    \\    
    \\        // Subscribe to trigger-send the {0s} message.
    \\        var trigger_behavior = try startup.triggers.{0s}.?.initBehavior();
    \\        errdefer {{
    \\            messenger.deinit();
    \\        }}
    \\        trigger_behavior.implementor = messenger;
    \\        trigger_behavior.triggerFn = &Messenger.trigger{0s}Fn;
    \\        try startup.triggers.{0s}.?.subscribe(trigger_behavior);
    \\        errdefer {{
    \\            messenger.deinit();
    \\        }}
    \\    
    \\        return messenger;
    \\    }}
    \\
    \\    pub fn deinit(self: *Messenger) void {{
    \\        self.allocator.destroy(self);
    \\    }}
    \\
    \\    /// receive{0s}Fn receives the "{0s}" message from the front-end.
    \\    /// It implements _channel_.FrontendToBackend.{0s}.Behavior.receiveFn found in deps/channel/fronttoback/{0s}.zig.
    \\    /// The receive{0s}Fn owns the message it receives.
    \\    pub fn receive{0s}Fn(implementor: *anyopaque, message: *Message) anyerror!void {{
    \\        var self: *Messenger = @alignCast(@ptrCast(implementor));
    \\        defer message.deinit();
    \\
    \\        self.receiveJob(message) catch |err| {{
    \\            // Fatal error.
    \\            self.exit(@src(), err, "self.receiveJob(message)");
    \\            return err;
    \\        }};
    \\        // If required, send a copy of this message back.
    \\        // Send a copy of the message back to the front-end.
    \\        // The channel owns the message so never deinit the message.
    \\        const copy = message.copy() catch |err| {{
    \\            // Fatal error.
    \\            self.exit(@src(), err, "message.copy()");
    \\            return err;
    \\        }};
    \\        self.send_channels.{0s}.send(copy) catch |err| {{
    \\            // Fatal error.
    \\            self.exit(@src(), err, "self.send_channels.{0s}.send(message)");
    \\            return err;
    \\        }};
    \\    }}
    \\
    \\    /// trigger{0s}Fn builds and sends the "{0s}" message to the front-end.
    \\    /// It implements _channel_.trigger.{0s}.Behavior.triggerFn found in deps/channel/trigger/{0s}.zig.
    \\    pub fn trigger{0s}Fn(implementor: *anyopaque) anyerror!void {{
    \\        var self: *Messenger = @alignCast(@ptrCast(implementor));
    \\
    \\        var message: *Message = self.triggerJob() catch |err| {{
    \\            // Fatal error.
    \\            self.exit(@src(), err, "self.triggerJob()");
    \\            return err;
    \\        }};
    \\        // Send the message back to the front-end.
    \\        // The sender owns the message so never deinit the message.
    \\        self.send_channels.{0s}.send(message) catch |err| {{
    \\            // Fatal error.
    \\            self.exit(@src(), err, "self.send_channels.{0s}.send(message)");
    \\            return err;
    \\        }};
    \\    }}
    \\
    \\    /// triggerJob creates message to send to the front-end.
    \\    /// Returns the processed message or an error.
    \\    /// KICKZIG TODO: Add the required functionality.
    \\    fn triggerJob(self: *Messenger) !*Message {{
    \\        _ = self;
    \\        // Create a message for the front-end.
    \\        // Set the message.backend_payload accordingly.
    \\        return error.KICKZIG_TODO_ADD_FUNCTIONALITY;
    \\    }}
    \\
    \\    /// receiveJob fullfills the front-end's request.
    \\    /// Returns nothing or an error.
    \\    /// KICKZIG TODO: Add the required functionality.
    \\    fn receiveJob(self: *Messenger, message: *Message) !void {{
    \\        _ = self;
    \\        _ = message;
    \\        // Do something for the front-end.
    \\        // Set the message.backend_payload accordingly.
    \\        return error.KICKZIG_TODO_ADD_FUNCTIONALITY;
    \\    }}
    \\}};
    \\
;
