const std = @import("std");
const fmt = std.fmt;

pub const Template = struct {
    allocator: std.mem.Allocator,
    message_names: [][]const u8,
    message_names_index: usize,

    // The caller owns the returned value.
    pub fn init(allocator: std.mem.Allocator) !*Template {
        var data: *Template = try allocator.create(Template);
        data.message_names = try allocator.alloc([]const u8, 5);
        errdefer {
            allocator.destroy(data);
        }
        data.message_names_index = 0;
        data.allocator = allocator;
        return data;
    }

    pub fn deinit(self: *Template) void {
        for (self.message_names, 0..) |name, i| {
            if (i == self.message_names_index) {
                break;
            }
            self.allocator.free(name);
        }
        self.allocator.free(self.message_names);
        self.allocator.destroy(self);
    }

    pub fn addName(self: *Template, new_name: []const u8) !void {
        var new_message_names: [][]const u8 = undefined;
        if (self.message_names_index == self.message_names.len) {
            // Full list so create a new bigger one.
            new_message_names = try self.allocator.alloc([]const u8, (self.message_names.len + 5));
            for (self.message_names, 0..) |name, i| {
                new_message_names[i] = name;
            }
            // Replace the old list with the new bigger one.
            self.allocator.free(self.message_names);
            self.message_names = new_message_names;
        }
        self.message_names[self.message_names_index] = try self.allocator.alloc(u8, new_name.len);
        @memcpy(@constCast(self.message_names[self.message_names_index]), new_name);
        self.message_names_index += 1;
    }

    // The caller owns the returned value.
    pub fn content(self: *Template) ![]const u8 {
        var line: []u8 = undefined;
        var lines = std.ArrayList(u8).init(self.allocator);
        defer lines.deinit();
        try lines.appendSlice(line_start);
        const names: [][]const u8 = self.message_names[0..self.message_names_index];
        for (names) |name| {
            line = try fmt.allocPrint(self.allocator, line_import_member, .{name});
            defer self.allocator.free(line);
            try lines.appendSlice(line);
        }
        try lines.appendSlice(line_messenger_struct_start);
        for (names) |name| {
            line = try fmt.allocPrint(self.allocator, line_messenger_struct_member, .{name});
            defer self.allocator.free(line);
            try lines.appendSlice(line);
        }
        try lines.appendSlice(line_fn_deinit);
        for (names) |name| {
            line = try fmt.allocPrint(self.allocator, line_deinit_member, .{name});
            defer self.allocator.free(line);
            try lines.appendSlice(line);
        }
        try lines.appendSlice(line_fn_deinit_end_fn_init_start);
        for (names) |name| {
            line = try fmt.allocPrint(self.allocator, line_member_init, .{name});
            defer self.allocator.free(line);
            try lines.appendSlice(line);
        }
        try lines.appendSlice(line_end);
        const temp: []const u8 = try lines.toOwnedSlice();
        line = try self.allocator.alloc(u8, temp.len);
        @memcpy(@constCast(line), temp);
        return line;
    }
};

const line_start: []const u8 =
    \\/// This is the back-end messenger's API.
    \\/// This file is re-generated by kickzig when you you add or remove a message.
    \\const std = @import("std");
    \\
    \\const _startup_ = @import("startup");
    \\
    \\
;
const line_import_member: []const u8 =
    \\const {0s}Messenger = @import("{0s}.zig").Messenger;
    \\
;

const line_messenger_struct_start: []const u8 =
    \\
    \\/// Messenger is the collection of the back-end messengers.
    \\/// These messengers are how the back-end communicate with the front-end.
    \\pub const Messenger = struct {
    \\    allocator: std.mem.Allocator,
    \\
;

const line_messenger_struct_member: []const u8 =
    \\    {0s}_messenger: ?*{0s}Messenger,
    \\
;

const line_fn_deinit: []const u8 =
    \\
    \\    pub fn deinit(self: *Messenger) void {
    \\
;

const line_deinit_member: []const u8 =
    \\        if (self.{0s}_messenger) |member| {{
    \\            member.deinit();
    \\        }}
    \\
;

const line_fn_deinit_end_fn_init_start: []const u8 =
    \\        self.allocator.destroy(self);
    \\    }
    \\
    \\    /// init constructs a Messenger.
    \\    /// It initializes each unique message handler.
    \\    pub fn init(startup: _startup_.Backend) !*Messenger {
    \\        var messenger: *Messenger = try startup.allocator.create(Messenger);
    \\        errdefer {
    \\            startup.allocator.destroy(messenger);
    \\        }
    \\        messenger.allocator = startup.allocator;
    \\
;

const line_member_init: []const u8 =
    \\        messenger.{0s}_messenger = try {0s}Messenger.init(startup);
    \\        errdefer messenger.deinit();
    \\
;

const line_end: []const u8 =
    \\        return messenger;
    \\    }
    \\};
    \\
;
