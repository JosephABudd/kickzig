const main_zig = @import("main_zig.zig");
const std = @import("std");

pub const file_name: []const u8 = "main.zig";

pub fn render(stream: anytype) !void {
    // beware of this dirty hack for pseudo-unused
    {
        const ___magic = .{stream};
        _ = ___magic;
    }
    // here comes the actual content
    try stream.writeAll("const std = @import(\"std\");\nconst dvui = @import(\"dvui\");\nconst SDLBackend = @import(\"SDLBackend\");\n\nconst frontend = @import(\"src/frontend/api.zig\");\nconst backend = @import(\"src/backend/api.zig\");\nconst channel = @import(\"channel\");\n\nvar gpa_instance = std.heap.GeneralPurposeAllocator(.{}){};\nconst gpa = gpa_instance.allocator();\n\nvar show_dialog_outside_frame: bool = false;\n\npub fn main() !void {\n    // init SDL gui_backend (creates OS window)\n    var gui_backend = try SDLBackend.init(.{\n        .width = 500,\n        .height = 600,\n        .vsync = true,\n        .title = \"GUI Standalone Example\",\n    });\n    defer gui_backend.deinit();\n\n    // init dvui Window (maps onto a single OS window)\n    var win = try dvui.Window.init(@src(), 0, gpa, gui_backend.backend());\n    defer win.deinit();\n\n    // GP allocator for backend and channels.\n    var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = general_purpose_allocator.allocator();\n\n    // The channels between the front and back ends.\n    var initialized_channels: bool = false;\n    const backToFront: *channel.Channels = try channel.init(allocator);\n    const frontToBack: *channel.Channels = try channel.init(allocator);\n\n    // Initialize the front and back ends.\n    try frontend.init(allocator, frontToBack, backToFront);\n    defer frontend.deinit();\n    try backend.init(allocator, backToFront, frontToBack);\n    defer backend.deinit();\n\n    main_loop: while (true) {\n        // Arena allocator for the front end.\n        var arena_allocator = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n        defer arena_allocator.deinit();\n        var arena = arena_allocator.allocator();\n\n        // beginWait coordinates with waitTime below to run frames only when needed\n        var nstime = win.beginWait(gui_backend.hasEvent());\n\n        // marks the beginning of a frame for dvui, can call dvui functions after this\n        try win.begin(arena, nstime);\n\n        // send all SDL events to dvui for processing\n        const quit = try gui_backend.addAllEvents(&win);\n        if (quit) break :main_loop;\n\n        try frontend.frame(arena);\n\n        if (!initialized_channels) {\n            initialized_channels = true;\n            // Send the initialize message telling the backend that the frontend is ready.\n            frontToBack.initialize.send();\n        }\n\n        // marks end of dvui frame, don't call dvui functions after this\n        // - sends all dvui stuff to gui_backend for rendering, must be called before renderPresent()\n        const end_micros = try win.end(.{});\n\n        // cursor management\n        gui_backend.setCursor(win.cursorRequested());\n\n        // render frame to OS\n        gui_backend.renderPresent();\n\n        // waitTime and beginWait combine to achieve variable framerates\n        const wait_event_micros = win.waitTime(end_micros, null);\n        gui_backend.waitEventTimeout(wait_event_micros);\n\n        // Example of how to show a dialog from another thread (outside of win.begin/win.end)\n        if (show_dialog_outside_frame) {\n            show_dialog_outside_frame = false;\n            try dvui.dialog(@src(), .{ .window = &win, .modal = false, .title = \"Dialog from Outside\", .message = \"This is a non modal dialog that was created outside win.begin()/win.end(), usually from another thread.\" });\n        }\n    }\n}");
}
